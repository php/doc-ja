<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: f46266c6d6a4e0fa713fbd0cf19c02e9650b5096 Maintainer: takagi Status: working -->
 <chapter xml:id="faq.passwords" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>安全なパスワードハッシュ</title>
  <titleabbrev>パスワードのハッシュ</titleabbrev>
  
  <para>
   この節では、なぜハッシュ関数を使ってパスワードを守るのかについての理由と、
   ハッシュ処理を効率的に行う方法について説明します。
  </para>
  
  <qandaset>
   <qandaentry xml:id="faq.passwords.hashing">
    <question>
     <para>
      なぜ、アプリケーションのユーザーが登録したパスワードをハッシュしなければならないのですか?
     </para>
    </question>
    <answer>
     <para>
      パスワードのハッシュは、最も基本的なセキュリティ要件のひとつです。
      ユーザーからパスワードを受け取るアプリケーションを設計するときには必ず考慮しなければなりません。
      ハッシュしなければ、パスワードを格納したデータベースが攻撃を受けたときにパスワードを盗まれてしまいます。
      それは即時にアプリケーションが乗っ取られることにつながるし、
      もしそのユーザーが他のサービスでも同じアカウント・同じパスワードを使っていればさらに被害が大きくなります。
     </para>
     <para>
      ユーザーのパスワードにハッシュアルゴリズムを適用してからデータベースに格納しておくと、
      攻撃者が元のパスワードを知ることが難しくなります。
      とはいえ、パスワードのハッシュ結果との比較は可能です。
     </para>
     <para>
      しかし、ここで注意すべき点は、パスワードのハッシュ処理はあくまでもデータベースへの不正アクセスからの保護にすぎず、
      アプリケーション自体に不正なコードを注入される攻撃からは守れないということです。
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.fasthash">
    <question>
     <para>
      よく使われるハッシュ関数である <function>md5</function> や
      <function>sha1</function> は、なぜパスワードのハッシュに適していないのですか?
     </para>
    </question>
    <answer>
     <para>
      MD5 や SHA1 そして SHA256 といったハッシュアルゴリズムは、
      高速かつ効率的なハッシュ処理のために設計されたものです。
      最近のテクノロジーやハードウェア性能をもってすれば、
      これらのアルゴリズムの出力をブルートフォースで(力ずくで)調べて元の入力を得るのはたやすいことです。
     </para>
     <para>
      最近のコンピュータではハッシュアルゴリズムを高速に「逆算」できるので、
      セキュリティ技術者の多くはこれらの関数をパスワードのハッシュに使わないよう強く推奨しています。
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.bestpractice">
    <question>
     <para>
      よく使われるハッシュ関数では不適切だというのなら、
      パスワードをどうやってハッシュすればいいのですか?
     </para>
    </question>
    <answer>
     <para>
      パスワードをハッシュするときに検討すべき重要な二点は、
      その計算量とソルトです。
      ハッシュアルゴリズムの計算コストが増えれば増えるほど、
      ブルートフォースによる出力の解析に時間を要するようになります。
     </para>
     <para>
      PHP 5.5 provides
      <link linkend="book.password">a native password hashing API</link> that
      safely handles both <link linkend="function.password-hash">hashing</link>
      and <link linkend="function.password-verify">verifying passwords</link>
      in a secure manner. There is also
      <link xlink:href="&url.password.compat;">a pure PHP compatibility library</link>
      available for PHP 5.3.7 and later.
     </para>
     <para>
      Another option is the <function>crypt</function> function, which
      supports several hashing algorithms in PHP 5.3 and later. When using
      this function, you are guaranteed that the algorithm you select is
      available, as PHP contains native implementations of each supported
      algorithm, in case one or more are not supported by your system.
     </para>
     <para>
      The suggested algorithm to use when hashing passwords is Blowfish, which
      is also the default used by the password hashing API, as it is
      significantly more computationally expensive than MD5 or SHA1, while
      still being scalable.
     </para>
     <para>
      Note that if you are using <function>crypt</function> to verify a
      password, you will need to take care to prevent timing attacks by using
      a constant time string comparison. Neither PHP's
      <link linkend="language.operators.comparison">== and === operators</link>
      nor <function>strcmp</function> perform constant time string
      comparisons. As <function>password_verify</function> will do this for
      you, you are strongly encouraged to use the
      <link linkend="book.password">native password hashing API</link>
      whenever possible.
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.passwords.salt">
    <question>
     <para>
      ソルトとは?
     </para>
    </question>
    <answer>
     <para>
      暗号理論におけるソルトとは、ハッシュ処理の際に追加するデータのことです。
      事前に計算済みのハッシュとその元入力の対応表 (レインボーテーブル)
      で出力を解析される可能性を減らすために利用します。
     </para>
     <para>
      端的に言うと、ソルトとはちょっとした追加データです。
      これをつけるだけで、ハッシュをクラックするのが劇的に難しくなります。
      事前に計算済みのハッシュとその元入力を大量にまとめた表が、オンラインで多数公開されています。
      ソルトを使えば、そのハッシュ値がこれらの表に含まれている可能性を大きく減らすことができます。
     </para>
     <para>
      <function>password_hash</function> will create a random salt if one
      isn't provided, and this is generally the easiest and most secure
      approach.
     </para>
    </answer>
   </qandaentry>
   <qandaentry xml:id="faq.password.storing-salts">
    <question>
     <para>
      How do I store my salts?
     </para>
    </question>
    <answer>
     <para>
      When using <function>password_hash</function> or
      <function>crypt</function>, the return value includes the salt as part
      of the generated hash. This value should be stored verbatim in your
      database, as it includes information about the hash function that was
      used and can then be given directly to
      <function>password_verify</function> or <function>crypt</function> when
      verifying passwords.
     </para>
     <para>
      The following diagram shows the format of a return value from
      <function>crypt</function> or <function>password_hash</function>. As you
      can see, they are self-contained, with all the information on the
      algorithm and salt required for future password verification.
     </para>
     <para>
      <mediaobject>
       <alt>
        The components of the value returned by password_hash and crypt: in
        order, the chosen algorithm, the algorithm's options, the salt used,
        and the hashed password.
       </alt>
       <imageobject>
        <imagedata fileref="en/faq/figures/crypt-text-rendered.svg" width="690" depth="192" format="SVG" />
       </imageobject>
      </mediaobject>
     </para>
    </answer>
   </qandaentry>
  </qandaset>
  
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
