<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 9e0f03ac354d797d1d16c0fcc1663e5e170f2727 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: shimooka,mumumu -->

<sect1 xml:id="language.oop5.decon" xmlns="http://docbook.org/ns/docbook">
 <title>コンストラクタとデストラクタ</title>

 <sect2 xml:id="language.oop5.decon.constructor">
  <title>コンストラクタ</title>
   <methodsynopsis xml:id="object.construct">
    <type>void</type><methodname>__construct</methodname>
    <methodparam rep="repeat"><type>mixed</type><parameter>values</parameter><initializer>""</initializer></methodparam>
   </methodsynopsis>
  <para>
   PHP 5 では、開発者がクラスのコンストラクタメソッドを宣言することが
   できます。コンストラクタメソッドを有するクラスは、新たにオブジェクトが
   生成される度にこのメソッドをコールします。これにより、
   そのオブジェクトを使用する前に必要な初期化を行うことができます。
  </para>
  <note>
   <simpara>
    子クラスがコンストラクタを有している場合、親クラスのコンストラクタが
    暗黙の内にコールされることはありません。
    親クラスのコンストラクタを実行するには、子クラスのコンストラクタの
    中で <function>parent::__construct</function> をコールすることが
    必要です。
    子クラスでコンストラクタを定義していない場合は、親クラスのコンストラクタを継承します
    (ただし、private 宣言されている場合は除く)。
    これは、通常のクラスメソッドと同様です。
   </simpara>
  </note>
  <example>
   <title>新しい統一されたコンストラクタを使用する</title>
   <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
    function __construct() {
        print "In BaseClass constructor\n";
    }
}

class SubClass extends BaseClass {
    function __construct() {
        parent::__construct();
        print "In SubClass constructor\n";
    }
}

class OtherSubClass extends BaseClass {
    // BaseClass のコンストラクタを継承します
}

// In BaseClass constructor
$obj = new BaseClass();

// In BaseClass constructor
// In SubClass constructor
$obj = new SubClass();

// In BaseClass constructor
$obj = new OtherSubClass();
?>
]]>
   </programlisting>
  </example>
  <para>
   PHP 3 や PHP 4 との下位互換性を維持するため、もし PHP がクラスの
   <link linkend="object.construct">__construct()</link> 関数を見つけられない場合は、
   古い形式のコンストラクタ (つまりクラス名と同じ名前の関数)を捜します。
   事実上、互換性の問題が発生する可能性があるのは、
   そのクラスが <link linkend="object.construct">__construct()</link> という名前のメソッドを
   異なる用途で用いてる場合だけです。
  </para>
   <!-- Not using an entity because I want specific wording here, since we're
   not deprecating constructors in general. -->
   <warning>
    <simpara>
     古い形式のコンストラクタは PHP 7.0 で <emphasis>非推奨</emphasis> となりました。
     将来のバージョンで削除されるでしょう。新しいコードでは常に
     <link linkend="object.construct">__construct()</link> を使うべきです。
    </simpara>
   </warning>
   <para>
    他のメソッドと異なり、親の <link linkend="object.construct">__construct()</link>
    と異なるパラメータで <link linkend="object.construct">__construct()</link>
    をオーバーライドしても PHP は
    <constant>E_STRICT</constant> エラーメッセージを出しません。
   </para>
   <para>
    PHP 5.3.3 以降、名前空間つきのクラス名の最後の部分と同じ名前のメソッドは
    コンストラクタとみなされなくなりました。
    名前空間を使っていないクラスは今までと変わりません。
   </para>
   <example>
    <title>名前空間つきのクラスのコンストラクタ</title>
    <programlisting role="php">
<![CDATA[
<?php
namespace Foo;
class Bar {
    public function Bar() {
        // PHP 5.3.0-5.3.2 までは、これはコンストラクタとみなされました
        // PHP 5.3.3 以降は、これはコンストラクタにはなりません
    }
}
?>
]]>
    </programlisting>
   </example>
 </sect2>

 <sect2 xml:id="language.oop5.decon.destructor">
  <title>デストラクタ</title>
   <methodsynopsis xml:id="object.destruct">
   <type>void</type><methodname>__destruct</methodname>
   <void />
  </methodsynopsis>
  <para>
   PHP 5 では、C++ のような他のオブジェクト指向言語に似た概念のデストラクタが
   導入されました。デストラクタメソッドは、
   特定のオブジェクトを参照するリファレンスがひとつもなくなったときにコールされます。
   あるいは、スクリプトの終了時にも順不同でコールされます。
  </para>
  <example>
   <title>デストラクタの例</title>
   <programlisting role="php">
<![CDATA[
<?php

class MyDestructableClass 
{
    function __construct() {
        print "In constructor\n";
    }

    function __destruct() {
        print "Destroying " . __CLASS__ . "\n";
    }
}

$obj = new MyDestructableClass();
 
]]>
   </programlisting>
  </example>
  <para>
   コンストラクタと同様、親クラスのデストラクタがエンジンにより暗黙のうちに
   コールされるということはありません。親クラスのデストラクタを実行するには、
   デストラクタの中で明示的に <function>parent::__destruct</function>
   をコールする必要があります。
   また、コンストラクタと同様、子クラスでデストラクタを定義していない場合は
   親クラスのデストラクタを継承します。
  </para>
   <para>
    <function>exit</function>
    でスクリプトの実行を止めた場合にもデストラクタはコールされます。
    デストラクタの内部で <function>exit</function> をコールすると、
    それ以降のシャットダウンルーチンを実行しません。
   </para>
   <note>
    <para>
     スクリプトのシャットダウン時にデストラクタがコールされた場合は、
     HTTP ヘッダはすでに送信されています。スクリプトのシャットダウン時の作業ディレクトリは、
     SAPI によっては (たとえば Apache など) 異なります。
    </para>
   </note>
   <note>
    <para>
     デストラクタの中から (スクリプトの終了処理時に)
     例外をスローしようとすると、致命的なエラーを引き起こします。
    </para>
   </note>
 </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
