<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision:$ -->
<!-- EN-Revision: a5c69fdd7097fe331da0f5d26edb4b48b9c48ae0 Maintainer: satoruyoshida Status: working -->
 <chapter xml:id="features.gc" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>ガベージコレクション</title>

  <para>
   このセクションでは、PHP 5.3 の一部の、新しいガベージコレクション（別名GC）機構の
   メリットを説明します。
  </para>

  <sect1 xml:id="features.gc.refcounting-basics">
   <title>参照カウント法の原理</title>
   <para>
    PHP 変数は「zval」と呼ばれるコンテナに保管されます。
    zval コンテナには、変数の型と値の他に、情報の追加ビットを2つ含みます。
    1つ目は「is_ref」と呼ばれ、変数が「参照集合」の一部かどうかを示すブール値
    です。
    このビットによって、通常の変数と参照を区別する方法を PHP エンジンが知ります。
    &amp;演算子によって作成されるように、PHP ではユーザーランドを参照できるので、
    zval コンテナもメモリー使用状況を最適化するための内部的な参照カウント機構を
    持ちます。
    追加情報の2つ目は「refcount」と呼ばれ、この1つの zval コンテナをどれだけ多くの
    変数名（シンボルとも呼ばれます）が指すかを含みます。
    シンボルは全てシンボルテーブルに保管され、スコープごとにシンボルテーブルの
    1つがあります。
    関数やメソッドごとのスコープばかりではなく、メインスクリプト用のスコープ
    （すなわち、ブラウザによってリクエストされたスクリプト）があります。
   </para>
   <para>
    新しい変数が定数値を使って作成されるとき、zval コンテナが作成されます。
    例えば、
    <example>
     <title>新規 zval コンテナを作成</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    この例では、新しいシンボル名（<literal>a</literal>）が現在のスコープで作成され、
    新しい変数コンテナが <type>string</type> 型と値 <literal>new string</literal>
    で作成されます。
    「is_ref」ビットはデフォルトで &false; にセットされます。なぜなら、ユーザーランド
    参照が作成されないからです。
    この変数コンテナを利用するシンボルが1つだけあるので、「refcount」は
    <literal>1</literal> に設定されます。
    「refcount」が <literal>1</literal> ならば、is_ref が常に &false; である点に
    注意してください。
    もし <link xlink:href='&url.xdebug;'>Xdebug</link> をインストール済みなら、
    <function>xdebug_debug_zval</function>を呼ぶとこの情報を表示できます。
   </para>
   <para>
    <example>
     <title>zval 情報を表示</title>
     <programlisting role="php">
<![CDATA[
<?php
xdebug_debug_zval('a');
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    この変数を他の変数名に代入すると、refcount が増加します。
   </para>
   <para>
    <example>
     <title>zval の refcount を増加</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
$b = $a;
xdebug_debug_zval( 'a' );
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=2, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    この時、refcount は <literal>2</literal> です。なぜなら、同じ変数コンテナが
    <varname>a</varname> と <varname>b</varname> にリンクされるからです。
    PHPは、必要ではない場合に実際の変数コンテナをコピーしないように十分スマートです。
    「refcount」がゼロに達すると、変数コンテナは破棄されます。
    変数コンテナにリンクされたあらゆるシンボルがスコープを抜ける
    （例えば関数が終わる）場合、またはシンボルに対して <function>unset</function>
    が呼ばれた場合に「refcount」が減少します。
    下記の例でこれを示します。
   </para>
   <para>
    <example>
     <title>zval refcount を減少</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = "new string";
$c = $b = $a;
xdebug_debug_zval( 'a' );
unset( $b, $c );
xdebug_debug_zval( 'a' );
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
a: (refcount=3, is_ref=0)='new string'
a: (refcount=1, is_ref=0)='new string'
]]>
     </screen>
    </example>
   </para>
   <para>
    次に、<literal>unset($a);</literal> を呼ぶと、（型と値を含む）変数コンテナが
    メモリから除去されます。
   </para>

   <sect2 xml:id="features.gc.compound-types">
    <title>複合型</title>

    <para>
     <type>array</type> や <type>object</type> のような複合型では、事情が少し
     複雑になります。
     <type>scalar</type> 値ではなく、<type>array</type> と <type>object</type>
     では、それらのプロパティをそれら自身のシンボルテーブルに保管します。
     これは、以下の例が3つの zval コンテナを作成することを意味します。
    </para>
    <para>
     <example>
      <title><type>array</type> zval を作成</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=1, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42
)
]]>
      </screen>
      <para>つまり、図で示すと</para>
      <mediaobject>
       <alt>単純配列に対する zval</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     3つのzvalコンテナは <varname>a</varname>、<varname>meaning</varname> および
     <varname>number</varname> です。「refcount」の増減に同様のルールが適用されます。
     下記では、配列に他の要素を追加して、既存の要素の内容をその値に設定します。
    </para>
    <para>
     <example>
      <title>既存の要素を配列に追加</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'meaning' => (refcount=2, is_ref=0)='life',
   'number' => (refcount=1, is_ref=0)=42,
   'life' => (refcount=2, is_ref=0)='life'
)
]]>
      </screen>
      <para>つまり、図で示すと</para>
      <mediaobject>
       <alt>参照を使った単純配列に対する zval</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/simple-array2.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     上記の Xdebug 出力では、新旧両方の配列要素が今や、refcount が <literal>2</literal>
     である zval コンテナを指すことがわかります。
     Xdebugの出力では、<literal>'life'</literal> という値の zval コンテナが2つ
     表示されますが、それらは同一です。
     <function>xdebug_debug_zval</function> 関数はこれを表示しませんが、
     メモリ・ポインターを示すことによってもそれを確かめられます。
    </para>
    <para>
     配列からの要素の除去は、スコープからシンボルを除去するようなものです。
     そうすることによって、配列要素が指すコンテナの「refcount」は、減少します。
     前と同じように、「refcount」がゼロに達すると、変数コンテナはメモリから
     除去されます。前と同じように、これを示す例です。
    </para>
    <para>
     <example>
      <title>配列から要素を除去</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
unset( $a['meaning'], $a['number'] );
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=1, is_ref=0)=array (
   'life' => (refcount=1, is_ref=0)='life'
)
]]>
      </screen>
     </example>
    </para>
    <para>
     次に、配列の要素として配列自体を追加すると、事情が面白くなります。
     次の例で行います、そこでは、参照演算子にこっそり入りもします。
     さもなければ PHP がコピーを作成するでしょう。
    </para>
    <para>
     <example>
      <title>それ自体の要素として配列自体を追加</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = array( 'one' );
$a[] =& $a;
xdebug_debug_zval( 'a' );
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
a: (refcount=2, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=2, is_ref=1)=...
)
]]>
      </screen>
      <para>つまり、図で示すと</para>
      <mediaobject>
       <alt>循環参照を使った配列に対する zval</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/loop-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     配列変数 (<varname>a</varname>) が２番目の要素 (<varname>1</varname>) と同様に
     「refcount」が <literal>2</literal> である変数コンテナを今や指していることがわかります。
     上記の表示の「...」は入り組んだ再帰があることを示します。
     もちろんこの場合には、「...」が元の配列を指すことを意味します。
    </para>
    <para>
     ちょうど前のように、変数をアンセットするとシンボルが除去されます。
     そして指す変数コンテナの参照カウントがアンセットにより減少します。
     従って、上記のコードを実行した後に変数 <varname>$a</varname> をアンセットすると、
     <varname>$a</varname> と要素「1」を指す変数コンテナの参照カウントは、
     アンセットにより「2」から「1」に減少します。これは次のように表現されます。
    </para>
    <para>
     <example>
      <title><varname>$a</varname> をアンセット</title>
      <screen>
<![CDATA[
(refcount=1, is_ref=1)=array (
   0 => (refcount=1, is_ref=0)='one',
   1 => (refcount=1, is_ref=1)=...
)
]]>
      </screen>
      <para>つまり、図で示すと</para>
      <mediaobject>
       <alt>メモリ・リークを実際に示す循環参照を使った配列を除去した後の zval</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/leak-array.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
   </sect2>

   <sect2 xml:id="features.gc.cleanup-problems">
    <title>片づけの問題</title>
    <para>
     この構造体を指すシンボルがいかなるスコープにももはや存在しないにもかかわらず、
     配列要素「1」がこの同じ配列をまだ指すので、片づけられません。
     それを指している外部シンボルがないので、ユーザーがこの構造体を片付ける方法が
     ありません。このようにしてメモリーリークとなります。
     幸いにも、PHP はリクエスト終了後、このデータ構造を片付けます、しかし、それ以前に
     これはメモリ内の貴重な空間を占めています。
     この状態は、「親」要素に再帰する「子」を持つ構文解析アルゴリズムなどの実装中に
     しばしば発生します。
     もちろんオブジェクトでも同じ状態が起こり得ます。オブジェクトは常に暗黙のうちに
     参照によって使われるので、実はその状態がより起こりそうです。
    </para>
    <para>
     これが 1、2 回起こるだけであるならば、これは問題でないかもしれません。しかし、
     これらのメモリ損失の数千または数百万さえあるならば、これは明らかに問題になり始めます。
     これは、例えばリクエストが基本的に決して終わらないデーモンのような、長くかかる
     実行中のスクリプトや、単体テストの大規模な集合で特に問題があります。
     後者は、eZ コンポーネント・ライブラリのテンプレート・コンポーネントに対して
     単体テストを実行中に問題を引き起こしました。
     いくらかの事例で、それは 2GB 以上のメモリを必要とします。そしてテストサーバーは全く
     持っていませんでした。
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="features.gc.collecting-cycles">
   <title>収集サイクル</title>
   <para>
    伝統的に、PHP で以前使われていたような参照カウント法記憶機構では、
    循環参照メモリ・リークに対処できません。
    しかしながら、5.3.0 現在、PHP ではその問題に焦点を当てた
    <link xlink:href='&url.gc-paper;'>Concurrent Cycle Collection in Reference Counted Systems</link>
    レポートに由来する同期アルゴリズムを実装しています。
   </para>
   <para>
    アルゴリズムの動作方法の詳しい説明がこのセクションの範囲の少し向こうにあります、
    しかし、基本はここで説明されます。
    まず第一に、いくつかの基本原則を確立しなければなりません。
    refcount が増やされたら、それはまだ使用中で、従ってゴミではありません。
    refcount が減少して、ゼロに達したら、zvalは解放可能です。
    refcount 引数がゼロ以外の値に減少する場合、これは、ガベージサイクルを作成できる
    だけであることを意味します。
    第２に、ガベージサイクルで、それらの refcount を減少させられるかどうかチェック
    することによって、どの部分がゴミか発見できます。
    可能です、そして、zval のうちいずれがゼロの refcountを持つか調べます。
   </para>
   <para>
     <mediaobject>
      <alt>ガベージコレクションのアルゴリズム</alt>
      <imageobject>
       <imagedata fileref="en/features/figures/gc-algorithm.png" format="PNG"/>
      </imageobject>
     </mediaobject>
   </para>
   <para>
    To avoid having to call the checking of garbage cycles with every possible
    decrease of a refcount, the algorithm instead puts all possible roots
    (zvals) in the "root buffer" (marking them "purple"). It also makes sure
    that each possible garbage root ends up in the buffer only once. Only when
    the root buffer is full does the collection mechanism start for all the
    different zvals inside. See step A in the figure above.
   </para>
   <para>
    In step B, the algorithm runs a depth-first search on all possible roots
    to decrease by one the refcounts of each zval it finds, making sure not to
    decrease a refcount on the same zval twice (by marking them as "grey"). In
    step C, the algorithm again runs a depth-first search from each root node,
    to check the refcount of each zval again. If it finds that the refcount is
    zero, the zval is marked "white" (blue in the figure). If it's larger than
    zero, it reverts the decreasing of the refcount by one with a depth-first
    search from that point on, and they are marked "black" again. In the last
    step (D), the algorithm walks over the root buffer removing the zval roots
    from there, and meanwhile, checks which zvals have been marked "white" in
    the previous step. Every zval marked as "white" will be freed.
   </para>
   <para>
    Now that you have a basic understanding of how the algorithm works, we
    will look back at how this integrates with PHP. By default, PHP's garbage
    collector is turned on. There is, however, a &php.ini;
    setting that allows you to change this: <option>zend.enable_gc</option>.
   </para>
   <para>
    When the garbage collector is turned on, the cycle-finding algorithm as
    described above is executed whenever the root buffer runs full. The root
    buffer has a fixed size of 10,000 possible roots (although you can alter
    this by changing the <literal>GC_ROOT_BUFFER_MAX_ENTRIES</literal> constant in
    <literal>Zend/zend_gc.c</literal> in the PHP source code, and re-compiling
    PHP). When the garbage collector is turned off, the cycle-finding
    algorithm will never run. However, possible roots will always be recorded
    in the root buffer, no matter whether the garbage collection mechanism has
    been activated with this configuration setting.
   </para>
   <para>
    If the root buffer becomes full with possible roots while the garbage
    collection mechanism is turned off, further possible roots will simply not
    be recorded. Those possible roots that are not recorded will never be
    analyzed by the algorithm. If they were part of a circular reference
    cycle, they would never be cleaned up and would create a memory leak. 
   </para>
   <para>
    The reason why possible roots are recorded even if the mechanism has been
    disabled is because it's faster to record possible roots than to have to
    check whether the mechanism is turned on every time a possible root could
    be found. The garbage collection and analysis mechanism itself, however,
    can take a considerable amount of time.
   </para>
   <para>
    Besides changing the <option>zend.enable_gc</option> configuration
    setting, it is also possible to turn the garbage collecting mechanism on
    and off by calling <function>gc_enable</function> or
    <function>gc_disable</function> respectively.  Calling those functions has
    the same effect as turning on or off the mechanism with the configuration
    setting. It is also possible to force the collection of cycles even if the
    possible root buffer is not full yet. For this, you can use the
    <function>gc_collect_cycles</function> function. This function will return
    how many cycles were collected by the algorithm. 
   </para>
   <para>
    The rationale behind the ability to turn the mechanism on and off, and to
    initiate cycle collection yourself, is that some parts of your application
    could be highly time-sensitive. In those cases, you might not want the
    garbage collection mechanism to kick in. Of course, by turning off the
    garbage collection for certain parts of your application, you do risk
    creating memory leaks because some possible roots might not fit into the
    limited root buffer. Therefore, it is probably wise to call
    <function>gc_collect_cycles</function> just before you call
    <function>gc_disable</function> to free up the memory that could be lost
    through possible roots that are already recorded in the root buffer. This
    then leaves an empty buffer so that there is more space for storing
    possible roots while the cycle collecting mechanism is turned off.
   </para>
  </sect1>

  <sect1 xml:id="features.gc.performance-considerations">
   <title>パフォーマンスの考慮点</title>
   <para>
    We have already mentioned in the previous section that simply collecting the
    possible roots had a very tiny performance impact, but this is when you
    compare PHP 5.2 against PHP 5.3. Although the recording of possible roots
    compared to not recording them at all, like in PHP 5.2, is slower, other
    changes to the PHP runtime in PHP 5.3 prevented this particular performance
    loss from even showing.
   </para>
   <para>
    There are two major areas in which performance is affected. The first
    area is reduced memory usage, and the second area is run-time delay when
    the garbage collection mechanism performs its memory cleanups. We will
    look at both of those issues.
   </para>

   <sect2 xml:id="features.gc.performance-considerations.reduced-mem">
    <title>Reduced Memory Usage</title>
    <para>
     First of all, the whole reason for implementing the garbage collection
     mechanism is to reduce memory usage by cleaning up circular-referenced
     variables as soon as the prerequisites are fulfilled. In PHP's
     implementation, this happens as soon as the root-buffer is full, or when
     the function <function>gc_collect_cycles</function> is called. In
     the graph below, we display the memory usage of the script below,
     in both PHP 5.2 and PHP 5.3, excluding the base memory that PHP
     itself uses when starting up.
    </para>
    <para>
     <example>
      <title>Memory usage example</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.1415962654';
}

$baseMemory = memory_get_usage();

for ( $i = 0; $i <= 100000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
    if ( $i % 500 === 0 )
    {
        echo sprintf( '%8d: ', $i ), memory_get_usage() - $baseMemory, "\n";
    }
}
?>
]]>
      </programlisting>
      <mediaobject>
       <alt>Comparison of memory usage between PHP 5.2 and PHP 5.3</alt>
       <imageobject>
        <imagedata fileref="en/features/figures/gc-benchmark.png" format="PNG"/>
       </imageobject>
      </mediaobject>
     </example>
    </para>
    <para>
     In this very academic example, we are creating an object in which a
     property is set to point back to the object itself. When the <varname>$a</varname> variable
     in the script is re-assigned in the next iteration of the loop, a memory
     leak would typically occur. In this case, two zval-containers are leaked
     (the object zval, and the property zval), but only one possible root is
     found: the variable that was unset. When the root-buffer is full after
     10,000 iterations (with a total of 10,000 possible roots), the garbage
     collection mechanism kicks in and frees the memory associated with those
     possible roots. This can very clearly be seen in the jagged memory-usage
     graph for PHP 5.3. After each 10,000 iterations, the mechanism kicks in
     and frees the memory associated with the circular referenced variables.
     The mechanism itself does not have to do a whole lot of work in this
     example, because the structure that is leaked is extremely simple. From
     the diagram, you see that the maximum memory usage in PHP 5.3 is about 9
     Mb, whereas in PHP 5.2 the memory usage keeps increasing.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.slowdowns">
    <title>Run-Time Slowdowns</title>
    <para>
     The second area where the garbage collection mechanism influences
     performance is the time taken when the garbage collection mechanism
     kicks in to free the "leaked" memory. In order to see how much this is,
     we slightly modify the previous script to allow for a larger number of
     iterations and the removal of the intermediate memory usage figures. The
     second script is here:
    </para>
    <para>
     <example>
      <title>GC performance influences</title>
      <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    public $var = '3.1415962654';
}

for ( $i = 0; $i <= 1000000; $i++ )
{
    $a = new Foo;
    $a->self = $a;
}

echo memory_get_peak_usage(), "\n";
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     We will run this script two times, once with the
     <option>zend.enable_gc</option> setting turned on, and once with it
     turned off:
    </para>
    <para>
     <example>
      <title>Running the above script</title>
      <programlisting role="shell">
<![CDATA[
time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php
# and
time php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php
]]>
      </programlisting>
     </example>
    </para>
    <para>
     On my machine, the first command seems to take consistently about 10.7
     seconds, whereas the second command takes about 11.4 seconds. This is a
     slowdown of about 7%. However, the maximum amount of memory used by the
     script is reduced by 98% from 931Mb to 10Mb. This benchmark is not very
     scientific, or even representative of real-life applications, but it
     does demonstrate the memory usage benefits that this garbage collection
     mechanism provides. The good thing is that the slowdown is always the
     same 7%, for this particular script, while the memory saving
     capabilities save more and more memory as more circular references are
     found during script execution.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.internal-stats">
    <title>PHP 内部の GC 統計</title>
    <para>
     It is possible to coax a little bit more information about how the
     garbage collection mechanism is run from within PHP. But in order to do
     so, you will have to re-compile PHP to enable the benchmark and
     data-collecting code. You will have to set the <literal>CFLAGS</literal>
     environment variable to <literal>-DGC_BENCH=1</literal> prior to running
     <literal>./configure</literal> with your desired options. The following
     sequence should do the trick:
    </para>
    <para>
     <example>
      <title>Recompiling PHP to enable GC benchmarking</title>
      <programlisting role="shell">
<![CDATA[
export CFLAGS=-DGC_BENCH=1
./config.nice
make clean
make
]]>
      </programlisting>
     </example>
    </para>
    <para>
     When you run the above example code again with the newly built PHP
     binary, you will see the following being shown after PHP has finished
     execution:
    </para>
    <para>
     <example>
      <title>GC 統計</title>
      <programlisting role="shell">
<![CDATA[
GC Statistics
-------------
Runs:               110
Collected:          2072204
Root buffer length: 0
Root buffer peak:   10000

      Possible            Remove from  Marked
        Root    Buffered     buffer     grey
      --------  --------  -----------  ------
ZVAL   7175487   1491291    1241690   3611871
ZOBJ  28506264   1527980     677581   1025731
]]>
      </programlisting>
     </example>
    </para>
    <para>
     The most informative statistics are displayed in the first block. You
     can see here that the garbage collection mechanism ran 110 times, and in
     total, more than 2 million memory allocations were freed during those
     110 runs. As soon as the garbage collection mechanism has run at least
     one time, the "Root buffer peak" is always 10000.
    </para>
   </sect2>

   <sect2 xml:id="features.gc.performance-considerations.conclusion">
    <title>結論</title>
    <para>
     In general the garbage collector in PHP will only cause a slowdown when the
     cycle collecting algorithm actually runs, whereas in normal (smaller)
     scripts there should be no performance hit at all.
    </para>
    <para>
     However, in the cases where the cycle collection mechanism does run for
     normal scripts, the memory reduction it will provide allows more of
     those scripts to run concurrently on your server, since not so much
     memory is used in total.
    </para>
    <para>
     The benefits are most apparent for longer-running scripts, such as
     lengthy test suites or daemon scripts. Also, for <link xlink:href="&url.php.gtk;">PHP-GTK</link> applications
     that generally tend to run longer than scripts for the Web, the new
     mechanism should make quite a bit of a difference regarding memory leaks
     creeping in over time.
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
