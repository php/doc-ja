 <chapter id="security">
  <title>セキュリティ</title>

  <simpara>
   PHP は強力な言語そしてインタプリタであり、モジュールとして Web サー
   バーに組み込んだ場合でも、独立した <acronym>CGI</acronym> バイナリ
   として実行される場合でも、ファイルをアクセスしたり、コマンドを実行
   したり、サーバーへのネットワーク接続を開くことができます。デフォル
   トでは、これらの機能を実行した場合、Webサーバー上でセキュリティ上の
   問題を生じる可能性があります。PHP は、特に CGI プログラムを書く場合、
   Perl や C より安全な言語となるように設計されています。コンパイル時
   または実行時の設定オプションを正しく選び、適切なコードを書くことに
   より、必要な自由度とセキュリティの組み合わせを確実に提供することが
   できます。
  </simpara>
  <simpara>
   PHP の使用法に多くの異なった手段があるように、PHP の動作を制御する
   多くの設定オプションがあります。オプションの選択肢が広いため、PHP
   を様々な用途に使用することができます。しかし、このことは、これらの
   オプションとサーバー設定の組み合わせによっては、安全でない設定とな
   ることを意味します。
  </simpara>
  <simpara>
   PHPの設定の自由度はそのコードの柔軟さにほぼ匹敵します。PHPは、シェ
   ルユーザコマンドを全て実行可能な完全なサーバーアプリケーションや
   厳しく制御された環境で低リスクの簡単なサーバーサイドインクルードを
   使用できるようなアプリケーションを構築する場合に使用することが可能
   です。そうした環境の構築方法、セキュリティのレベルはPHPの開発者に大
   きく依存しています。
  </simpara>
  <simpara>
   本章は、安全に使用可能な異なった設定と条件の組み合わせについての説
   明から始めます。続いて、複数のセキュリティレベルのコーディングにお
   ける複数の考慮事項について説明し、最後にいくつかの一般的なセキュリ
   ティ上のアドバイスを行います。
  </simpara>

  <sect1 id="security.cgi">
   <title>CGI バイナリとしてインストール</title>
   
   <sect2 id="security.cgi.attacks">
    <title>有りうる攻撃</title>

    <simpara>
     PHP を <acronym>CGI</acronym> バイナリとして使用するのは、PHP を
     モジュールとして(Apache のような)サーバーソフトウエアに組み込み
      たくない何らかの理由がある場合や安全な chroot と setuid 環境をス
     クリプトに提供する他の CGI ラッパーと組み合わせて PHP を使用する
     場合の設定オプションです。セットアップ時には、通常、PHP 実行バイ
     ナリを Web サーバーの cgi-bin ディレクトリにインストールします。
     CERT 勧告 <ulink url="&url.cert;">CA-96.11</ulink>は、いかなるイ
     ンタプリタを cgi-bin に置くことにも反対しています。
     PHP バイナリをスタンドアロンのインタプリタとして使用することが
     できる場合でも、PHP は、セットアップにより生じる可能性がある
     次のような攻撃を防ぐように設計されています。
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       システムファイルへのアクセス: <filename
       role="url">http://my.host/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
       URL において疑問符 (?) の後のクエリー情報は、CGI インターフェー
       スにより、インタプリタにコマンドライン引数として渡されます。通
       常、インタプリタは、コマンドライン上の最初の引数に指定されたファ
       イルを開き、実行します。
      </simpara>
      <simpara>
       CGI バイナリとして実行された場合、PHP は、コマンドライン引数の
       解釈を拒否します。
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       サーバー上の Web ドキュメントへのアクセス: <filename
       role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
       URL の PHP バイナリ名の後のパス情報の部分、つまり<filename
       role="uri">/secret/doc.html</filename> は、
       <acronym>CGI</acronym> プログラムによりオープンされて実行される
       ファイルの名前を指定するために従来より使用されています。
       <filename role="url">http://my.host/secret/script.php3</filename>
       のようなドキュメントへの要求を PHP インタプリタにリダイレクト
       するために、通常、何らかの Web サーバー設定用命令(Apache では Action)
       が使用されます。この設定により、Web サーバーは、まずディレクトリ 
       <filename role="uri">/secret</filename> へのアクセス権をチェックし、
       リダイレクト要求 <filename
       role="url">http://my.host/cgi-bin/php/secret/script.php3</filename>
       を生成します。残念なことに、リクエストが最初からこの形式で与え
       られた場合、Web サーバーによるアクセスチェックは、
       <filename role="uri">/secret/script.php3</filename> ファイル
       ではなく、<filename role="uri">/cgi-bin/php</filename> ファイル
       に対して行われます。この手法により、<filename
       role="uri">/cgi-bin/php</filename> にアクセス可能なユーザーは、
       Web サーバー上の全ての保護されたドキュメントにアクセスできてし
       まいます。
      </simpara>
      <simpara>
       PHP では、サーバードキュメントツリーにアクセス制限付きのディレ
       クトリがある場合、コンパイル時の設定オプション <link
       linkend="install.configure.enable-force-cgi-redirect">
	--enable-force-cgi-redirect</link> および実行時の設定命令
       <link linkend="ini.doc-root">doc_root</link> と
       <link linkend="ini.user-dir">user_dir</link> をこの攻撃を防止す
       るために使用することができます。  これらを組み合わせたいくつか
       の手法について以下に詳細な説明を示します。
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="security.cgi.default">
    <title>ケース 1: 公開ファイルのみを配布</title>
    <simpara>
     サーバー上にパスワードまたは IP アドレスを元にしたアクセス制限に
     よる制約を受けるコンテンツがない場合、この設定オプションを使用す
     る必要はありません。使用する Web サーバーがリダイレクトを許可しな
     い場合やサーバーがリダイレクト要求を安全に処理しつつPHP バイナリ
     と通信できる手段を有していない場合、オプション <link
     linkend="install.configure.enable-force-cgi-redirect">
      --disable-force-cgi-redirect</link>を
     configure スクリプトに指定することができます。この場合でも、直接
     的な方法 <filename
     role="php">http://my.host/cgi-bin/php/dir/script.php3</filename>
     でもなくリダイレクション <filename
     role="php">http://my.host/dir/script.php3</filename>でもない他の
     やり方で PHP スクリプトを呼び出せるようになっていないかどうか確認
     する必要があります。
    </simpara>
    <simpara>
     リダイレクションは、例えば Apache では命令 AddHandler および
     Action で設定することができます。(以下を参照してください。)
    </simpara>
   </sect2>
   
   <sect2 id="security.cgi.force-redirect">
    <title>ケース 2: --enable-force-cgi-redirect を使用</title>
    <simpara>
     このコンパイル時のオプションは、
     <filename role="php">http://my.host/cgi-bin/php/secretdir/script.php3
     </filename> のように URL から直接 PHP を呼び出すことを禁止します。
     代わりに、
     Web サーバーのリダイレクションにより処理された場合は、
     PHP はこのモードでのみ処理を行います。
    </simpara>
    <simpara>
     通常、Apache 用設定でのリダイレクションは、
     次の命令を使用して行います。</simpara>
    <programlisting role="apache-conf">
Action php3-script /cgi-bin/php
AddHandler php3-script .php3
    </programlisting>
    <simpara>
     このオプションは、Apache Web サーバーでのみテストされており、リク
     エストのリダイレクト時に Apache が標準ではないCGI 環境変数
     <envar>REDIRECT_STATUS</envar> をセットすることを前提にしています。
     リクエストが直接のものであるか間接のものであるかを示す手段をWeb
     サーバーが全くサポートしていない場合は、このオプションを使用する
     ことはできません。この場合、ここで記した CGI 版を実行する他の方法
     の内の一つを使用する必要があります。
    </simpara>
   </sect2>
   
   <sect2 id="security.cgi.doc-root">
    <title>ケース 3: doc_root または user_dir を設定</title>
    <simpara>
     Web サーバー上のドキュメントディレクトリに
     スクリプトや実行ファイルのようなアクティブな内容を読み込むのは、
     往々にして危険な行為であるとみなされることがあります。
     何らかの設定ミスによりスクリプトが実行されず、通常の HTML ドキュメント
     として表示されてしまう場合には、知的著作物またはパスワードのような
     セキュリティ情報が漏洩する可能性があります。
     このため、多くのシステム管理者は、スクリプトを PHP CGI を通じてのみ
     アクセス可能な他のディレクトリ構造にセットアップしたいと思うこと
     でしょう。
     この場合、常にインタープリタに処理されるため、上記のように表示されること
     はありません。
    </simpara>
    <simpara>
     前節で記したようなリクエストがリダイレクトされたものでないことを
     確かめる方法が利用可能でない場合、
     スクリプト用の doc_root を Web ドキュメント用ルートとは別に
     セットアップする必要があります。
    </simpara>
    <simpara>
     設定用命令 <link linkend="ini.doc-root">doc_root</link> により
     <link linkend="configuration.file">設定ファイル</link> ファイル中で
     PHP スクリプト用ドキュメントルートを設定することができます。
     または、環境変数 <envar>PHP_DOCUMENT_ROOT</envar> でも設定する
     ことができます。
     これを設定した場合、CGI 版の PHP は、     
     常に開くファイルの名前をこの <parameter>doc_root</parameter> 
     リクエストのパス情報を用いて作成し、
     (以下の <parameter>user_dir</parameter> を除き、)確実に
     このディレクトリの外側でスクリプトが実行されないようにします。
    </simpara>
    
    <simpara>
     ここで利用可能な別のオプションは、<link linkend="ini.user-dir">
      user_dir</link> です。user_dir が設定されていない場合、
     開かれるファイル名を制御するのは、<parameter>doc_root</parameter>
     のみです。
     <filename role="url">http://my.host/~user/doc.php3</filename> のような
     URL は、ユーザーホームディレクトリ以下のファイルを開かず、
     doc_root 以下の <filename role="uri">~user/doc.php3</filename> 
     というファイルを開くことになります。
     (ディレクトリ名がチルダ [<literal>~</literal>] で始まっている
     ということになります)
    </simpara>
    <simpara>
     user_dir が例えば、<filename role="dir">public_php</filename>に
     設定されていた場合、
     <filename role="url">http://my.host/~user/doc.php3</filename> の
     ようなリクエストは、そのユーザー user のホームディレクトリにある
     <filename role="dir">public_php</filename> 以下の
     <filename>doc.php3</filename> という名前のファイルをオープンしま
     す。ユーザーのホームディレクトリが、
     <filename role="dir">/home/user</filename> である場合、
     実行されるファイルは、
     <filename>/home/user/public_php/doc.php3</filename>
     となります。
    </simpara>
    <simpara>
     <parameter>user_dir</parameter> の展開は、
     <parameter>doc_root</parameter> の設定によらず行われます。
     このため、ドキュメントルートおよびユーザーディレクトリへの
     アクセスを別々に制御することができます。
    </simpara>
   </sect2>
   
   <sect2 id="security.cgi.shell">
    <title>ケース 4: web ツリーの外に PHP パーサを置く</title>
    <para>
     非常に安全性の高いオプションとしてPHP パーサのバイナリをファイル
     用 Web ツリーの外側、例えば <filename
     role="dir">/usr/local/bin</filename>に置くことが考えられます。こ
     のオプションの唯一の欠点は、PHP タグを有する全てのファイルの先頭
     行に次のような一行を加える必要があることです。
     <informalexample>
      <programlisting>
#!/usr/local/bin/php
      </programlisting>
     </informalexample>
     また、ファイルを実行可能にしておく必要があります。この場合、実行
     時にシェルエスケープ機能 <literal>#!</literal> を使用する Perl や
     sh や他のスクリプト言語で書かれた CGI スクリプトを処理するのと全
     く同様に処理を行います。
    </para>
    <para>
     この設定で <envar>PATH_INFO</envar> および
     <envar>PATH_TRANSLATED</envar> 情報を正しく処理するためには、
     PHP パーサを設定オプション
     <link linkend="install.configure.enable-discard-path">
      --enable-discard-path</link> を付けてコンパイルする必要があります。
    </para>
   </sect2>
  </sect1>
  
  <sect1 id="security.apache">
   <title>Apache モジュールとしてインストール</title>
   <simpara>
    PHP が Apache モジュールとして使用された場合、PHP は、Apache ユー
    ザーの許可属性(通常はユーザー "nobody" の許可属性)を継承します。
    これは、セキュリティと認証に数々の影響を与えます。例えば、データベー
    スと接続するためにPHPを使用している場合、データベースが組込みのア
    クセス制御機能を有していない限り、そのデータベースを "nobody"ユー
    ザからアクセス可能とする必要が生じます。これは、悪意のあるスクリプ
    トが、ユーザ名とパスワードなしにデータベースにアクセスし、修正する
    ことができることを意味します。Webスパイダがデータベース管理用Webペー
    ジを回って、データベースを全て削除することも可能です。Apache認証に
    よりこの攻撃に対して防衛することが可能であり、また、LDAPや
    .htaccessファイル等を使用して固有のアクセスモデルを設計し、PHPスク
    リプトの一部としてそのコードをインクルードすることも可能です。
   </simpara>
   <simpara>
    しばしば、PHPユーザ(この場合は、Apacheユーザ)に関するセキュティ
    上のリスクが非常に小さいという観点で一旦セキュリティが確立されると、
    PHPは、ユーザディレクトリにウイルスファイルを書き込んだり、非公開の
    データベースにアクセスしたり変更したりといったことが出来なくなりま
    す。しかし、同じくファイルの書き込みやデータベーストランザクション
    に関して所要の安全性が確保されていると言えます。この観点からしばし
    ば行われるセキュリティ上の失敗としてApacheにルート権限を与えるとい
    うものがあります。
   </simpara>
   <simpara>
    Apacheユーザの権限をルートに昇格させることは非常に危険であり、シ
    ステム全体を危険にさらす可能性があります。よって、sudoやchrootの実
    行、ルートȩ限で実行を行う他の手段は、セキュリティに精通した人以外
    は、考慮するべきではありません。
   </simpara>
  </sect1>

  <sect1 id="security.filesystem">
   <title>ファイルシステムのセキュリティ</title>
   <simpara>
    PHP は、ファイルおよびディレクトリ毎に権限を設定する多くのサーバシ
    ステム上に組み込まれたセキュリティを提供します。これにより、ファイ
    ルシステム内のファイルを読み込み可能に制御することが可能になります。
    全てのファイルは世界中から読み込み可能であり、このファイルシステム
    にアクセスした全てのユーザから読み込まれても安全であることを確認す
    る必要があります。
   </simpara>
   <simpara>
    PHPは、ファイルシステムにユーザレベルのアクセスを許可するように設
    計されているため、PHPスクリプトから/etc/password のようなシステム
    ファイルを読み込み可能とすることができます。これから明らかにわかる
    ことですが、読み書きするファイルを適切に設定する必要があります。
    各自のホームディレクトリにあるファイルを削除する次のスクリプトを見
    てみましょう。これは、ファイル管理用にWebインターフェースを使用す
    る場合に通常生じるような設定を仮定しています。
    この場合、Apacheユーザはそのユーザのホームディレクトリにあるファイ
    ルを削除可能です。
   </simpara>
   <para>
    <example>
     <title>甘い変数の確認から生じるリスク</title>
     <programlisting role="php">
&lt;?php
// ユーザのホームディレクトリからファイルを削除する
$username = $user_submitted_name;
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ($homedir/$userfile);
echo "$file_to_delete has been deleted!";
?>
     </programlisting>
    </example>
    usernameはユーザフォームから投稿可能であるため、usernameを投稿し、
    他の誰かが所有するファイルを指定、削除することが可能です。この場合、
    他の何らかの形式の認証を使用するべきです。投稿された変数が、
    "../etc/" と "passwd " であった場合について考えてみましょう。簡単
    なコードを以下に示します。
    <example>
     <title>... ファイルシステムへの攻撃</title>
     <programlisting role="php">
&lt;?php
// 外部からPHPユーザがアクセス可能なハードドライブを削除します。PHPが
// ルートのアクセス権限を有している場合、
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd" has been deleted!";
?>
     </programlisting>
    </example>   
    こうした問題を防止するための適切なチェック手段として以下の2種類が
    あります。
    <itemizedlist>
     <listitem>
      <simpara>
       PHP Webユーザバイナリに制限された権限のみを許可する。
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       ファイルに関連する投稿された全ての変数を確認する。
      </simpara>
     </listitem>
    </itemizedlist>
    以下に改良されたスクリプトを示します。
    <example>
     <title>より安全なファイル名の確認</title>
     <programlisting role="php">
&lt;?php
// PHPユーザがアクセス可能なハードドライブからファイルを削除する。
$username = $HTTP_REMOTE_USER; // 認証機構を使用する

$homedir = "/home/$username";

$file_to_delete = basename("$userfile"); // パスを取り除く
unlink ($homedir/$file_to_delete);

$fp = fopen("/home/logging/filedelete.log","+a"); // 削除の記録
$logstring = "$HTTP_REMOTE_USER $homedir $file_to_delete";
fputs ($fp, $logstring);
fclose($fp);

echo "$file_to_delete has been deleted!";
?>
     </programlisting>
    </example>      
   </para>   
  </sect1>
  
  <sect1 id="security.variables">
   <title>ユーザが送信したデータ</title>
   <para>
    多くのPHPで最も脆弱な部分は、言語自体に起因するものではなく、単に
    セキュリティを考慮して書かれていないコードの問題です。この原因につ
    いて、指定したコードの部分の意味を常に時間をかけて吟味し、予想外の
    変数が投稿された場合に有り得る損害を確かめる必要があります。
    <example>
     <title>危険な変数の使用</title>
     <programlisting role="php">
&lt;?php
// ユーザのホームディレクトリからファイルを削除します... または他の誰
// かのディレクトリかも?
unlink ($evil_var);

// 彼らのアクセスのログを書き込む.. または違うかも?
fputs ($fp, $evil_var);

// 何かちょっとしたことを実行.. または rm -rf *?
system ($evil_var);
exec ($evil_var);

?>
     </programlisting>
    </example>
    常に注意してコードをテストし、Webブラウザから投稿された全ての変数
    について次のような点を確認して下さい。
    <itemizedlist>
     <listitem>
      <simpara>
       このスクリプトは、意図したファイルのみを受け付けるか?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       例外的なまたは意図したもの以外のデータにより実行することが可能
       か?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       このスクリプトは意図した以外の方法で使用することが可能か?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       このスクリプトは、悪い意味で他のスクリプトと組み合わせて使用す
       ることが可能か?
      </simpara>
     </listitem> 
     <listitem>
      <simpara>
       トランザクションは適切に記録されているか?
      </simpara>
     </listitem>
    </itemizedlist>
    スクリプトを書いた後ではなく、書いている時にこれらの質問を適宜行う
    ことにより、セキュリティ改善のために不幸にして書き直しが必要になる
    ということを避けることができます。こうした考慮をまず行うことにより、
    システムのセキュリティを保証できるわけではありませんが、改善の一助
    にはなりえます。
   </para>
  </sect1>
  
  <sect1 id="security.general">
   <title>一般的な考慮事項</title>
   <simpara>
    完全に安全なシステムは理想の産物でしかないため、セキュリティ業界で
    しばしば使用される手法は、リスクと利便性のバランスのとれた手法です。
    変数がユーザから投稿される度に(網膜スキャンと指紋のような)2種類の
    生体認証が必要だとしたら、極端に高いレベルの説明義務を生じます。ま
    た、かなり複雑なフォームを埋めるために30分もかかるとすれば、ユーザ
    がセキュリティをバイパスする手段を探す気分にさせる傾向があります。
    最善のセキュリティは、通常、ユーザによる業務の達成を防たげずに要求
    を十分に達成できる程度にさしでがましくないものです。むしろ、いくつ
    かのセキュリティ攻撃は、単純にこの種の多げさに構築されたセキュリティ
    を狙うものです。
   </simpara>
   <simpara>
    記憶するに値する言葉として次のようなものがあります。「システムは鎖
    の最も弱い輪と同程度に優れている」全てのトランザクションが時間、場
    所、トランザクションの型等に基づき大量に記録されているが、ユーザは
    一つのクッキーのみにより認証されている場合、ユーザとそのトランザク
    ションログの結び付きの確実性はかなり弱くなります。
   </simpara>
   <simpara>
    テストの際に、最も簡単なページに関してでさえ、全ての可能性をテスト
    することは不可能であるということを頭に入れておいて下さい。期待する
    入力は、不機嫌な社員、経験のあるクラッカー、キーボードの上を歩く家
    の猫による入力とは全く無関係でしょう。これが、想定外のデータが入力
    される可能性がある場所を見分けるために論理的な視点からコードを見て、
    その後、修正、減少、または詳細に調べるというのが、最善であるという
    理由です。
   </simpara>
   <simpara>
    インターネットにはあなたのコードを壊したり、システムを破壊したり、
    不適切な内容を投稿したり、その他あなたの一日を不快にするようなこと
    により自分の名を馳せたいと思う人がたくさんいます。サイトの規模の大
    小によらず、単にオンラインであり、接続できるサーバを有しているだけ
    で攻撃目標となりえます。多くのクラック用プログラムはサイトの大きさ
    を考慮せず、犠牲者を探しつつ大きなIPブロックで網を張っています。
   </simpara>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

