<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 96c9d88bad9a7d7d44bfb7f26c226df7ee9ddf26 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: shimooka -->

<sect1 xml:id="language.oop5.decon" xmlns="http://docbook.org/ns/docbook">
 <title>コンストラクタとデストラクタ</title>

 <sect2 xml:id="language.oop5.decon.constructor">
  <title>コンストラクタ</title>
  <methodsynopsis>
   <type>void</type><methodname>__construct</methodname>
   <methodparam choice="opt"><type>mixed</type><parameter>args</parameter></methodparam>
   <methodparam choice="opt"><parameter>...</parameter></methodparam>
  </methodsynopsis>
  <para>
   PHP 5 では、開発者がクラスのコンストラクタメソッドを宣言することが
   できます。コンストラクタメソッドを有するクラスは、新たにオブジェクトが
   生成される度にこのメソッドをコールします。これにより、
   そのオブジェクトを使用する前に必要な初期化を行うことができます。
  </para>
  <note>
   <simpara>
    子クラスがコンストラクタを有している場合、親クラスのコンストラクタが
    暗黙の内にコールされることはありません。
    親クラスのコンストラクタを実行するには、子クラスのコンストラクタの
    中で <function>parent::__construct</function> をコールすることが
    必要です。
   </simpara>
  </note>
  <example>
   <title>新しい統一されたコンストラクタを使用する</title>
   <programlisting role="php">
<![CDATA[
<?php
class BaseClass {
   function __construct() {
       print "In BaseClass constructor\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "In SubClass constructor\n";
   }
}

$obj = new BaseClass();
$obj = new SubClass();
?>
]]>
   </programlisting>
  </example>
  <para>
   下位互換性を維持するため、PHP 5 が指定されたクラスの
   <function>__construct</function> 関数をみつけられない場合には、
   古い形式のコンストラクタ関数、つまり、そのクラスの名前と同じ関数が探されます。
   実際、互換性の問題が発生する可能性があるのは、
   そのクラスが <function>__construct</function> という名前のメソッドを
   有しており、それが異なる用途で使用されている場合です。
  </para>
   <para>
    他のメソッドと異なり、親の <function>__construct</function>
    と異なるパラメータで <function>__construct</function>
    をオーバーライドしても PHP は
    <constant>E_STRICT</constant> エラーメッセージを出しません。
   </para>
 </sect2>

 <sect2 xml:id="language.oop5.decon.destructor">
  <title>デストラクタ</title>
  <methodsynopsis>
   <type>void</type><methodname>__destruct</methodname>
   <void />
  </methodsynopsis>
  <para>
   PHP 5 では、C++ のような他のオブジェクト指向言語に似た概念のデストラクタが
   導入されました。デストラクタメソッドは、特定のオブジェクトへの全てのリファレンスが
   削除された直後やオブジェクトが明示的に破棄された直後にコールされます。
   あるいは、スクリプトの終了時にも順不同でコールされます。
  </para>
  <example>
   <title>デストラクタの例</title>
   <programlisting role="php">
<![CDATA[
<?php
class MyDestructableClass {
   function __construct() {
       print "In constructor\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Destroying " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?>
]]>
   </programlisting>
  </example>
  <para>
   コンストラクタと同様、親クラスのデストラクタがエンジンにより暗黙のうちに
   コールされるということはありません。親クラスのデストラクタを実行するには、
   デストラクタの中で明示的に <function>parent::__destruct</function>
   をコールする必要があります。
  </para>
   <para>
    <function>exit</function> でスクリプトの実行を止めた場合にもデストラクタはコールされます。
    デストラクタの内部で <function>exit</function> をコールすると、
    それ以降のシャットダウンルーチンを実行しません。
   </para>
   <note>
    <para>
     スクリプトのシャットダウン時にデストラクタがコールされた場合は、
     HTTP ヘッダはすでに送信されています。スクリプトのシャットダウン時の作業ディレクトリは、
     SAPI によっては (たとえば Apache など) 異なります。
    </para>
   </note>
   <note>
    <para>
     デストラクタの中から (スクリプトの終了処理時に)
     例外をスローしようとすると、致命的なエラーを引き起こします。
    </para>
   </note>
 </sect2>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
