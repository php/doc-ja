<reference id="ref.pcre">
  <title>Perl互換の正規表現関数</title>
  <titleabbrev>PCRE</titleabbrev>   

  <partintro>
   <para>
    この関数で使用されるパターンに関する構文は、Perl に非常によく似ています。
    表現は、デリミタ、例えばスラッシュ (/) で囲まれる必要があります。
    英数字またはバックスラッシュ(\)以外の全ての文字をデリミタとして
    使用可能です。デリミタ文字を正規表現本体において使用する必要がある場合は、
    バックスラッシュでエスケープする必要があります。
   </para>
   <para>
    マッチングに影響を与える様々な修正子を終端デリミタの後に付ける
    ことができます。
    <link linkend="pcre.pattern.modifiers">パターン修正子</link>
    を参照下さい。
   </para>
   <para>
    <example>
     <title>有効なパターンの例</title>
     <itemizedlist>
      <listitem><simpara>/<\/\w+>/</simpara></listitem>
      <listitem><simpara>|(\d{3})-\d+|Sm</simpara></listitem>
      <listitem><simpara>/^(?i)php[34]/</simpara></listitem>
     </itemizedlist>
    </example>
   </para>
   <para>
    <example>
     <title>無効なパターンの例</title>
     <itemizedlist>
      <listitem>
       <simpara>
	/href='(.*)' - 終端デリミタが抜けている
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	/\w+\s*\w+/J - 未知の修正子 'J'
       </simpara>
      </listitem>
      <listitem>
       <simpara>
	1-\d3-\d3-\d4| - 始端デリミタが抜けている
       </simpara>
      </listitem>
     </itemizedlist>
    </example>
   </para>
   <note>
    <simpara>
     Perl互換の正規表現関数は、PHP4およびPHP3.0.9以降で利用可能です。
    </simpara>
   </note>
  </partintro>
  
  <refentry id="function.preg-match">
   <refnamediv>
    <refname>preg_match</refname>
    <refpurpose>正規表現検索を行う</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>preg_match</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>subject</parameter></paramdef>
      <paramdef>array 
       <parameter><optional>matches</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <parameter>pattern</parameter>で指定した正規表現により
     <parameter>subject</parameter>を検索します。
    </para>
    <para>
     <parameter>matches</parameter>が指定された場合、検索結果が代入されます。
     $matches[0]はパターン全体にマッチしたテキストが代入され、
     $matches[1]は最初の括弧付きのサブパターンにマッチしたテキスト
     が代入され、といったようになります。
    </para>
    <para>
     文字列subjectに<parameter>pattern</parameter>がマッチした場合は
     trueを返し、マッチしなかったか、エラーを発生した場合にfalseを
     返します。
    </para>
    <para>
     <example>
      <title>文字列"php"を探す</title>
      <programlisting role="php">
// パラメータのデリミタの後の"i"は大文字小文字を区別しない検索を示します
if (preg_match ("/php/i", "PHP is the web scripting language of choice.")) {
    print "A match was found.";
} else {
    print "A match was not found.";
}
      </programlisting>
     </example>
     <example>
      <title>単語"web"を探す</title>
      <programlisting role="php">
// パターン内の\bは単語の境界を示します。このため、独立した単語の
// "web"にのみマッチし、"webbing" または "cobweb"のような単語の一
//  部にはマッチしません
if (preg_match ("/\bweb\b/i", "PHP is the web scripting language of choice.")) {
    print "A match was found.";
} else {
    print "A match was not found.";
}
if (preg_match ("/\bweb\b/i", "PHP is the website scripting language of choice.")) {
    print "A match was found.";
} else {
    print "A match was not found.";
}
      </programlisting>
     </example>
     <example>
      <title>URLからドメイン名を得る</title>
      <programlisting role="php">
preg_match("/^(.*)([^\.]+\.[^\.]+)(\/.*)?/U",
       "http://www.php.net/index.html", $matches);
// 2番目の括弧内のパターンを表示
echo "domain name is: ".$matches[2]."\n"; 
      </programlisting>
     </example>
     この例の出力は以下となります。
     <programlisting>
domain name is: php.net
     </programlisting>
     <function>preg_match_all</function>, 
     <function>preg_replace</function>, 
     <function>preg_split</function>も参照下さい。
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.preg-match-all">
   <refnamediv>
    <refname>preg_match_all</refname>
    <refpurpose>グローバル正規表現検索を行う</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>int <function>preg_match_all</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>subject</parameter></paramdef>
      <paramdef>array <parameter>matches</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>order</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <parameter>subject</parameter>において
     <parameter>pattern</parameter>で指定した正規表現にマッチする
     かどうかを検索し、<parameter>order</parameter>で指定した
     順番で <parameter>matches</parameter>に結果を代入します。
    </para>
    <para>
     最初にマッチするものが見つかった後、最後にマッチしたパターンの後から
     検索が続行されます。
    </para>
    <para>
     <parameter>order</parameter>は、次の2つのどちらかとなります。
     <variablelist>
      <varlistentry>
       <term>PREG_PATTERN_ORDER</term>
       <listitem>
	<para>
	 $matches[0] がパターン全体にマッチする配列であり、
	 $matches[1] が最初の括弧で括られたサブパターンにマッチする
	 文字列の配列であり、といった順番となります。
	 <informalexample>
	  <programlisting role="php">
preg_match_all ("|&lt;[^>]+>(.*)&lt;/[^>]+>|U", 
    "&lt;b>example: &lt;/b>&lt;div align=left>this a test&lt;/div>", 
    $out, PREG_PATTERN_ORDER);
print $out[0][0].", ".$out[0][1]."\n";
print $out[1][0].", ".$out[1][1]."\n"
	  </programlisting>
	 </informalexample>
	 この例の出力は以下のようになります。
	 <informalexample>
	  <programlisting>
&lt;b>example: &lt/b>, &lt;div align=left>this is a test&lt;/div>
example: , this is a test
	  </programlisting>
	 </informalexample>
	 $out[0]は、パターン全体にマッチする文字列の配列を有しており、
	 $out[1]は、タグで囲まれた文字列の配列を有しています。
	</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>PREG_SET_ORDER</term>
       <listitem>
	<para>
	$matches[0]は最初にマッチした組の配列であり、
	$matches[1]は二番目にマッチした組の配列であり、
	といった順序となります。
	 <informalexample>
	  <programlisting role="php">
preg_match_all ("|&lt;[^>]+>(.*)&lt;/[^>]+>|U",
    "&lt;b>example: &lt;/b>&lt;div align=left>this a test&lt;/div>", 
    $out, PREG_SET_ORDER);
print $out[0][0].", ".$out[0][1]."\n";
print $out[1][0].", ".$out[1][1]."\n"
	  </programlisting>
	 </informalexample>
	 この例の出力は以下のようになります。
	 <informalexample>
	  <programlisting role="php">
&lt;b>example: &lt;/b>, example: 
&lt;div align=left>this is a test&lt;/div>, this is a test
	  </programlisting>
	 </informalexample>
	 この場合、$matches[0] は最初にマッチした組であり、
	 $matches[0][0] はパターン全体にマッチしたテキスト、
	 $matches[0][1] は最初のサブパターンにマッチしたテキスト、
	 といったようになります。
	 同様に、$matches[1]は二番目にマッチした組といったようになり
	 ます。
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     <parameter>order</parameter>が指定されない場合、PREG_PATTERN_ORDER
     を仮定します。
    </para>
    <para>
     パターンがマッチした総数を返します。または、マッチしなかったか、
     エラーが発生した場合にfalseを返します。
    </para>
    <para>
     <example>
      <title>テキストから全ての電話番号を得る</title>
      <programlisting role="php">
preg_match_all ("/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x",
               "Call 555-1212 or 1-800-555-1212", $phones);
      </programlisting>
     </example>
    </para>
    <para>
     <example>
      <title>HTMLタグにマッチするものを見付ける(greedy)</title>
      <programlisting role="php">
// the \\2 is an example of backreferencing. This tells pcre that
// it must match the 2nd set of parenthesis in the regular expression
// itself, which would be the ([\w]+) in this case.
$html = "&lt;b&gt;bold text&lt;b&gt;lt;a href=howdy.html&gt;click me&lt;a&gt;

preg_match_all ("/(&lt;([\w]+)[^&gt;]*&gt;)(.*)(&lt;\/\\2&gt;)/", 
                $html, $matches);

for ($i=0; $i&lt; count($matches[0]); $i++) {
       echo "matched: ".$matches[0][$i]."\n";
       echo "part 1: ".$matches[1][$i]."\n";
       echo "part 2: ".$matches[3][$i]."\n";
       echo "part 3: ".$matches[4][$i]."\n\n";
}
      </programlisting>
     </example>
     この例の出力は以下となります。
     <programlisting>
matched: &lt;b&gt;bold text&lt;b&gt;
part 1: &lt;b&gt;
part 2: bold text
part 3: &lt;b&gt;

matched: &lt;a href=howdy.html&gt;click me&lt;a&gt;
part 1: &lt;a href=howdy.html&gt;
part 2: click me
part 3: &lt;a&gt;
     </programlisting>
    </para>
    <simpara>
     <function>preg_match</function>,
     <function>preg_replace</function>,
     <function>preg_split</function>も参照下さい。
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.preg-replace">
   <refnamediv>
    <refname>preg_replace</refname>
    <refpurpose>正規表現検索および置換を行う</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>preg_replace</function></funcdef>
      <paramdef>mixed <parameter>pattern</parameter></paramdef>
      <paramdef>mixed <parameter>replacement</parameter></paramdef>
      <paramdef>mixed <parameter>subject</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>limit</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <parameter>subject</parameter>に関して
     <parameter>pattern</parameter>を用いて検索を行い、
     <parameter>replacement</parameter>に置換します。
     <parameter>limit</parameter>を指定した場合、<parameter>limit</parameter>
     回のマッチまで置換が行なわれます。<parameter>limit</parameter>が
     省略されるか -1 の場合、マッチするものは全て置換されます。
    </para>
    <para>
     <parameter>replacement</parameter>では、
     <literal>\\<replaceable>n</replaceable></literal>形式または
     (PHP 4.0.4 以降) <literal><replaceable>$n</replaceable></literal>
     形式で参照を指定することができます。後者の形式の方が好ましい形式
     です。各参照は、<replaceable>n</replaceable>番目の括弧で括られた
     パターンにマッチしたテキストにより置換されます。
     <replaceable>n</replaceable>は0から99までとすることができ、
     <literal>\\0</literal> または <literal>$0</literal> はパターン全
     体にマッチするテキストを参照します。マッチしたサブパターンの番号
     を得るために左括弧は(1から始まって)左から右に番号がふられます。
    </para>
    <para>
     <parameter>subject</parameter>においてマッチしなかった場合、
     変更されずに返されます。
    </para>
    <para>
     <function>preg_replace</function>に渡す全てのパラメータは配列とする
     ことができます。
    </para>
    <para>
     <parameter>subject</parameter>が配列の場合、検索及び置換は
     <parameter>subject</parameter>の各エントリ毎に行われ、
     返り値も配列として返されます。
    </para>
    <para>
     <parameter>pattern</parameter>および<parameter>replacement</parameter>
     が配列の場合、
     <function>preg_replace</function>は各配列からの値を用いて
     <parameter>subject</parameter>に関する検索および置換を行います。
     <parameter>replacement</parameter>の値が
     <parameter>pattern</parameter>よりも少ない場合、残りの置換用文字列
     に関して空の文字列が使用されます。
     パターン<parameter>pattern</parameter>が配列で
     <parameter>replacement</parameter>が文字列の場合、この置換文字列
     は <parameter>pattern</parameter>の各値毎に使用されます。
     しかし、逆の場合は意味がありません。
    </para>
    <para>
     <literal>/e</literal>修正子は、
     <function>preg_replace</function>が
     <parameter>replacement</parameter>パラメータを適当な置換を
     行った後、PHP コードとして処理するようにします。
     注意: 
     <parameter>replacement</parameter> が有効なPHPコード文字列から
     構成されるようにしてください。そうでない場合、
     <function>preg_replace</function> のある行で
     PHP は構文エラーを発生します。
     <note>
      <para>
      この修正子は PHP 4.0 で追加されました。
      </para>
     </note>
    </para>
    <para>
     <example>
      <title>複数の値を置換する</title>
      <programlisting role="php">
$patterns = array ("/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/",
                    "/^\s*{(\w+)}\s*=/");
$replace = array ("\\3/\\4/\\1\\2", "$\\1 =");
print preg_replace ($patterns, $replace, "{startDate} = 1999-5-27");
      </programlisting>
     </example>
     この例の出力は次のようになります。
     <programlisting>
      $startDate = 5/27/1999
     </programlisting>
     <example>
      <title>/e 修正子の使用法</title>
      <programlisting role="php">
preg_replace ("/(<\/?)(\w+)([^>]*>)/e", 
              "'\\1'.strtoupper('\\2').'\\3'", 
              $html_body);
      </programlisting>
      <para>
       入力テキストの全てのHTMLタグを大文字に変換します。
      </para>
     </example>
     <example>
      <title>HTMLをテキストに変換する</title>
      <programlisting role="php">
// $document には、HTMLドキュメントが含まれている必要があります。
// このドキュメントのHTMLタグおよびjavascriptの部分と空白文字を
// 削除します。また、いくつかのHTMLエンティティを等価なテキストに
// 変換します。
	  
$search = array ("'&lt;script[^&gt;]*?&gt;.*?&lt;/script&gt;'si",   
                                                // javascriptを削除
                 "'&lt;[\/\!]*?[^&lt;&gt;]*?&gt;'si",  // htmlタグを削除
                 "'([\r\n])[\s]+'",  // 空白文字を削除
                 "'&amp;(quot|#34);'i",  // htmlエンティティを置換
                 "'&amp;(amp|#38);'i",
                 "'&amp;(lt|#60);'i",
                 "'&amp;(gt|#62);'i",
                 "'&amp;(nbsp|#160);'i",
                 "'&amp;(iexcl|#161);'i",
                 "'&amp;(cent|#162);'i",
                 "'&amp;(pound|#163);'i",
                 "'&amp;(copy|#169);'i",
                 "'&amp;#(\d+);'e");  // phpとして評価

$replace = array ("",
                  "",
                  "\\1",
                  "\"",
                  "&amp;",
                  "&lt;",
                  "&gt;",
                  " ",
                  chr(161),
                  chr(162),
                  chr(163),
                  chr(169),
                  "chr(\\1)");

$text = preg_replace ($search, $replace, $document);
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      パラメータ<parameter>limit</parameter>はPHP 4.0.1pl2で追加されま
      した。
     </para>
    </note>	 
    <para>
     <function>preg_match</function>,
     <function>preg_match_all</function>, 
     <function>preg_split</function>も参照下さい。
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.preg-split">
   <refnamediv>
    <refname>preg_split</refname>
    <refpurpose>正規表現で文字列を分割する</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array preg_split</funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>string <parameter>subject</parameter></paramdef>
      <paramdef>int 
       <parameter><optional>limit</optional></parameter>
      </paramdef>
      <paramdef>int 
       <parameter><optional>flags</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <note>
     <para>
      パラメータ<parameter>flags</parameter>は、PHP4 Beta3で追加されました。
     </para>
    </note>
    <para>
     <parameter>pattern</parameter>にマッチした境界で分割した
     <parameter>subject</parameter>の部分文字列を有する配列を返します。
    </para>
    <para>
     <parameter>limit</parameter>が指定された場合、最大
     <parameter>limit</parameter>個の部分文字列のみが返されます。
    </para>
    <para>
     flagsが<constant>PREG_SPLIT_NO_EMPTY</constant>の場合、空でない要
     素のみが<function>preg_split</function>により返されます。
    </para>
    <example>
     <title><function>preg_split</function> の例</title>
     <para>
      検索文字列の部分を取得します。
     </para>
     <programlisting role="php">
// " ", \r, \t, \n , \f を含むカンマまたは空白文字で句を分割します。
$keywords = preg_split ("/[\s,]+/", "hypertext language, programming");
      </programlisting>
     <para>
      文字列を文字要素に分割します。
     </para>
     <programlisting role="php">
$str = 'string';
$chars = preg_split('//', $str, 0, PREG_SPLIT_NO_EMPTY);
print_r($chars);
     </programlisting>
    </example>
    <para>
     <function>preg_match</function>,
     <function>preg_match_all</function>, 
     <function>preg_replace</function>も参照下さい。
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.preg-quote">
   <refnamediv>
    <refname>preg_quote</refname>
    <refpurpose>正規表現文字をクオートする</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>preg_quote</function></funcdef>
      <paramdef>string <parameter>str</parameter></paramdef>
      <paramdef>string 
       <parameter><optional>delimiter</optional></parameter>
      </paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>preg_quote</function>は、<parameter>str</parameter> 
     を引数とし、正規表現構文の部分の各文字の前にバックスラッシュを挿入
     します。この関数は、
     なんらかのテキストと実行時に入力される文字列をマッチさせる
     必要があり、文字列には正規表現の特殊文字が含まれている場合に、
     便利です。
    </para>
    <para>
     オプションの<parameter>delimiter</parameter>が指定された場合、こ
     こで指定した文字もエスケープされます。これは、PCRE関数が使用する
     デリミタをエスケープする場合に便利です。'/'がデリミタとしては最も
     一般的に使用されています。
    </para>
    <para>
     正規表現の特殊文字は、次のようなものです。
     <screen>. \\ + * ? [ ^ ] $ ( ) { } = ! < > | :</screen>
    </para>
    <para>
     <example>
      <title>例:</title>
      <programlisting role="php">
$keywords="$40 for a g3/400";
$keywords = preg_quote ($keywords, "/");
echo $keywords; // \$40 for a g3\/400 を返します。
      </programlisting>
     </example>
     <example>
      <title>テキストの中の単語を置換する</title>
      <programlisting role="php">

// In this example, preg_quote($word) is used to keep the
// asterisks from having special meaning to the regular
// expression.

$textbody = "This book is *very* hard to find.";
$word = "*very*";
$textbody = preg_replace ("/".preg_quote($word)."/",
                         "&lt;i&gt;".$word."&lt;/i&gt;",
                          $textbody);
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.preg-grep">
   <refnamediv>
    <refname>preg_grep</refname>
    <refpurpose>
     パターンにマッチする配列の要素を返す
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>array <function>preg_grep</function></funcdef>
      <paramdef>string <parameter>pattern</parameter></paramdef>
      <paramdef>array <parameter>input</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
     <function>preg_grep</function>は、指定した 
     <parameter>pattern</parameter>にマッチする
     <parameter>input</parameter>配列の要素からなる配列を返します。
    </para>
    <para>
     <example>
      <title><function>preg_grep</function>の例</title>
      <programlisting role="php">
// return all array elements
// containing floating point numbers
$fl_array = preg_grep ("/^(\d+)?\.\d+$/", $array);
      </programlisting>
     </example>
    </para>
   </refsect1>
  </refentry>

  <refentry id="pcre.pattern.modifiers">
   <refnamediv>
    <refname>Pattern Modifiers</refname>
    <refpurpose>正規表現パターンで使用可能な修正子を得る</refpurpose>
   </refnamediv>
   <refsect1>
    <title>説明</title>
    <para>
     現在使用可能なPCRE修正子の一覧を以下に示します。
     括弧の中の名前は、これらの修正子に関するPCRE内部の名前です。
    </para>
    <para>
     <blockquote>
      <variablelist>
       <varlistentry>
	<term><emphasis>i</emphasis> (PCRE_CASELESS)</term>
	<listitem>
	 <simpara>
	 この修正子が設定されている場合、パターンの中の文字は
	 大文字にも小文字にもマッチします。
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>m</emphasis> (PCRE_MULTILINE)</term>
	<listitem>
	 <simpara>
	  デフォルトで、PCREは検索対象文字列を(実際には複数行からなる
	  場合でも)単一の行からなるとして処理します。
	  "行頭"メタ文字 (^) は文字列の最初にしかマッチしません。
	  一方、"行の終端"メタ文字 ($) は文字列の終わりまたは
	  (<emphasis>E</emphasis> 修正子が設定されていない場合、)
	  終端を表す改行記号の前のみにしかマッチしません。
	  この動作は Perl と同じです。
	 </simpara>
	 <simpara>
	  この修正子が設定された場合、"行頭"および"行末"は
	  subject文字列において、文字列の最初と最後と同じに、
	  各改行の直前と直後にそれぞれマッチします。
	  この動作は、Perl の /m 修正子と同じです。
	  subject 文字列の中に "\n" 文字がない場合、
	  またはパターンに ^ または $ がない場合、
	  この修正子を設定しても意味はありません。
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>s</emphasis> (PCRE_DOTALL)</term>
	<listitem>
	 <simpara>
	  この修正子が設定された場合、パターン中のドットメタ文字は
	  改行を含む全ての文字にマッチします。
	  これを指定しない場合、改行は除かれます。
	  この修正子は、Perl の /s 修正子と等価です。
	  [^a] のような否定クラスは、
	  この修正子の設定によらず、常に改行文字にマッチします。
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>x</emphasis> (PCRE_EXTENDED)</term>
	<listitem>
	 <simpara>
	  この修正子が設定された場合、エスケープするか
	  文字クラスの内部にある場合を除き、
	  パターンの空白文字は完全に無視されます。
	  エスケープされていない文字クラスの外にある # と次の改行文字の間
	  の文字も無視されます。
	  この動作は、Perl の /x 修正子と同じであり、複雑なパターンの内部に
	  コメントを含むことが可能となります。
	  しかし、この修正子は、データ文字にのみ適用されることに注意
	  して下さい。空白文字をパターンの特殊文字の並びの中、
	  例えば条件付サブパターン(?) の内部に置くことはできません。 
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>e</emphasis></term>
	<listitem>
	 <simpara>
	  この修正子が設定されている場合、<function>preg_replace</function>
	  は、置換文字列において後方参照に関する通常の置換を行った後、
	  PHP コードとして評価し、検索文字列を置換するためにその結果を
	  使用します。
	 </simpara>
	 <simpara>
	  この修正子を使用するのは、<function>preg_replace</function>のみです。
	  他の PCRE 関数では無視されます。
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>A</emphasis> (PCRE_ANCHORED)</term>
	<listitem>
	 <simpara>
	  この修正子が設定された場合、パターンは強制的に"anchored"となります。
	  この場合、検索される文字列("検索対象文字列")の先頭に
	  のみマッチするように制限されます。
	  パターン自体の中に適当な指定を行うことでも
	  同様の効果を得ることが可能で、Perlではこの方法しか使用
	  できません。
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>D</emphasis> (PCRE_DOLLAR_ENDONLY)</term>
	<listitem>
	 <simpara>
	  この修正子が設定されている場合、パターン内のメタ記号のドル
	  は、検索対象文字列の終わりにのみマッチします。
	  この修正子を指定しない場合、ドル記号は改行文字の直前の
	  文字(ただし、改行文字以外)にもマッチします。
	  この修正子は、<emphasis>m</emphasis> が設定されている場合に
	  無視されます。
	  Perlには、この修正子に等価なものはありません。
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>S</emphasis></term>
	<listitem>
	 <simpara>
	  あるパターンを複数回使用する場合、マッチングにかかる時間を
	  高速化することを目的として、パターン解析により時間をかける
	  価値があります。
	  この修正子を設定した場合、このようなより時間をかけた解析が
	  行われます。現在、パターン解析は、
	  最初の文字が単一の固定されていないアンカー付きでないパターンでのみ
	  有用です。
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>U</emphasis> (PCRE_UNGREEDY)</term>
	<listitem>
	 <simpara>
	  この修正子は、
	  デフォルトで貪欲でないが、"?" が後に付くと貪欲になる
	  量子化器の欲さを反転します。
	  この修正子はPerl互換では有りません。
	  この修正子の指定は、(?U) 修正子のようにもパターン内でも行うことが
	  できます。
	 </simpara>
	</listitem>
       </varlistentry>
       <varlistentry>
	<term><emphasis>X</emphasis> (PCRE_EXTRA)</term>
	<listitem>
	 <simpara>
	  この修正子は、Perl と互換性がない PCRE の付加的な機能をオンにします。
	  パターン内で後ろに文字が続くバックスラッシュで特別な意味がない
	  ものは、将来的な拡張の際の互換性の維持のため、エラーになります。
	  デフォルトでは、Perl のように文字が後ろに続くバックスラッシュ
	  で特に意味がないものは、リテラルとして処理されます。
	  この修正子より制御される機能は、現在他にありません。
	 </simpara>
	</listitem>
       </varlistentry>
      </variablelist>
     </blockquote>
    </para>
   </refsect1>
  </refentry>

  <refentry id="pcre.pattern.syntax">
   <refnamediv>
    <refname>Pattern Syntax</refname>
    <refpurpose>PCRE 正規表現の説明</refpurpose>
   </refnamediv>

   <refsect1>
    <title>説明</title>
    <literallayout>
     PCRE ライブラリは、(以下に示す)僅かな違いを除き Perl 5 と同じ構文と
     意味を使用した正規表現パターンマッチングを実装した関数群です。
     現在の実装は、Perl 5.005 に対応しています。
    </literallayout>
   </refsect1>

   <refsect1>
    <title>Perl との差</title>
    <literallayout>
    ここで説明するのは、Perl 5.005 に関連するものです。

     1. デフォルトでは空白文字は C ライブラリ関数 isspace() が
     認識する全ての文字ですが、別の文字型テーブルを用いてPCREを
     コンパイルすることも可能です。
     通常、isspace() は空白、フォームフィード、改行、複改、
     水平タブ、垂直タブにマッチします。
     Perl 5 ではもう空白文字の中に垂直タブを含んでいません。
     かなり前から Perl ドキュメントにあった \v エスケープは、
     実際は認識されていませんでした。
     しかし、その文字自体は少なくとも 5.002 までは空白文字として
     処理されていま?_。
     5.004 および 5.005 では、この文字は \s にマッチしません。

     2. PCRE では、先読み言明(assertion)時に繰り返し数の指定を使用できません。
     Perl はこれを許可しますが、意図した通りに動作することを
     意味するわけではありません。
     例えば、(?!a){3} は、次の3文字が "a" でないことを
     言明するわけではありません。
     この指定は、次の文字が "a" ではないことを3回言明するだけです。

     3. 否定の先読み言明の中で生じるサブパターンを取得する回数は計算され
     ますが、オフセットベクトルの中の対応するエントリは設定されません。
     Perl では、言明のマッチングに失敗する前にマッチした
     パターンからその変数を設定しますが、それが行われるのは、
     否定の先読み言明の枝が1つだけの場合のみです。

     4. ヌル文字文字は、検索対象文字列でサポートされますが、
     パターン文字列ではサポートされません。
     これは、パターン文字列は、0 を終端とする通常の C 文字列として
     渡されるためです。
     エスケープシーケンス "\0" は、ヌル文字を表すパターンとして
     使用することが可能です。

     5. 次の Perl エスケープシーケンスは、サポートされません。:
     \l,  \u,  \L,  \U,  \E, \Q
     実際、Perl では、これらはパターンマッチングエンジンの部分ではなく、
     通常の文字列処理の部分に実証されています。

     6. Perl の \G 言明は、一回のパターンマッチに関するものではないため、
     サポートされません。

     7. 明確に述べると、PCRE は (?{code}) 構造をサポートしません。

     8. 
     Perl 5.005_02 では、書きこみ時に
     パターンの一部を繰り返す際に取ޗした文字列の設定に関連する
     奇妙な動作が見うけられます。
     例えば、"aba" をパターン /^(a(b)?)+$/ にマッチングする場合、
     $2 には、値 "b" が設定されますが、"aabbaa" を /^(aa(bb)?)+$/ 
     にマッチさせた場合、$2 は設定されません。
     しかし、パターンを/^(aa(b(b))?)+$/に変えると、$2 (および $3)
     が設定されます。

     Perl 5.004 では、$2 はどちら?±ースでも設定されます。
     これは、PCRE でも匦ǘです。尦ݥ的に Perl が別の矛盾のない
     状態に変更された場合、PCRE も追従する可能性があります。

     9. 他の未解決の矛盾は、Perl 5.005_02 では、パターン
     /^(a)?(?(1)a|b)+$/ は文字列 "a" にマッチしますが、
     PCRE ではマッチしないということです。
     しかし、Perl と PCRE は共に /^(a)?a/ で "a" をマッチした
     場合に $1 が未定義のままとなります。

     10. PCRE  は、Perl 正規表現の機能にいくつかの拡張機能を提供します。

     (a) 先読み言明は、固定長の文字列にマッチする必要がありますが、
    先読み言明の別の各枝は、異なった長さの文字列にマッチすることが
    できます。Perl 5.005 では全て同じ長さである必要があります。

     (b) PCRE_DOLLAR_ENDONLY が設定されており、PCRE_MULTILINE が
     設定されていない場合、メタ文字 $ は、文字列の終端にのみマッチします。

     (c) PCRE_EXTRA が設定されている場合、バックスラッシュの後に
     文字があって特に意味がないものは、エラーとなります。

     (d) PCRE_UNGREEDY が設定されていゥ4合、デフォルトでは
     貪欲でない繰り返し指定子の貪欲さは反転しますが、
     疑問符が後ろにつく場合は、貪欲になります。
    </literallayout>
   </refsect1>

   <refsect1>
    <title>正規表現の詳細</title>
    <literallayout>
     PCRE によりサポートされる正規表現の構文を以下に示します。
     正規表現は、Perl のドキュメントや他の多くの書籍において
     豊富な例と共に説明されています。
     Jeffrey Friedl が書いた O'Reilly 発刊の 
     "Mastering  Regular  Expressions" には、詳細が示されています。
     ここでの説明はリファレンスドキュメントとして使用することを
     意図しています。
    
     正規表現はパターンであり、検索対象文字列に対して左から右にマッチングが
     行われます。
     パターンの中の多くの文字はそれ自体を表し、検索対象の対応する文字に
     マッチします。簡単な例をあげると、次のパターン

       The quick brown fox

     は、検索対象文字列のそれ自体と同じ部分にマッチします。
     正規表現の強力さは、パターン中に複数の選択肢や繰り返し
     を含む能力によるものです。
     これらは、<emphasis>メタ</emphasis>-<emphasis>文字</emphasis> を
     使用したパターンによりエンコードされます。
     メタ文字はそれ自体を表しませんが、代わりに特有の解釈が行われます。

     2種類のメタ文字が存在します。片方は、ブラケットの中以外にあるパターン
     で使用可能なもので、もう片方は、ブラケットの中で使用可能なものです。
     ブラケットの外で使用されるメタ文字には次のようなものがあります。

       \      一般的なエスケープ文字
       ^      検索対象(複数行モードでは行)の始まりを言明 
       $      検索対象(複数行モードでは行)の終わりを言明
       .      (デフォルトでは)改行を除く全ての文字にマッチ
       [      文字クラス開始を定義
       |      選択枝の開始
       (      サブパターンの開始
       )      サブパターンの終了
       ?      ( の意味を拡張する
              または、0 または1 回の繰り返し
	      または、繰り返しを最小化する
       *      0 以上の繰り返し
       +      1 以上の繰り返し
       {      最小/最大繰り返しの開始

     パターン中でブラケットの中の部分は、"文字クラス" と呼ばれます。
     文字クラスで使えるメタ文字は次のものだけです。

       \      一般的なエスケープ文字
       ^      最初の文字に用いた場合のみ、クラスを否定
       -      文字の範囲を示す
       ]      文字クラスの終了

     次のセクションで、各メタ文字の使用法の説明を行います。

バックスラッシュ
     バックスラッシュには、いくつかの使用法があります。まず、
     英字でない文字が後に続く場合、そてև字が有する
     特別な意味は失われます。このバックスラッシュの使い方は、
     文字クラスの内側と外側の両方で使用可能です。

     例えば、"*" 文字にマッチさせたい場合、パターンに "\*" を書きます。
     これにより、次の文字がメタ文字として解釈されようとされまいと、"\" を伴った英字でない文字が、その文字自体を表すことを保証します。特に、バックスラッシュにマッチさせたい場合は、"\\" と書きます。

     パターンが、 PCRE_EXTENDED オプションを付けてコンパイルされている
     場合、(文字クラスの中でない)パターン内の空白文字および
     "#" と次の改行文字の間の文字は無視されます。
     空白文字または "#" をパターンの一部として含める際には、
     バックスラッシュによりエスケープすることができます。

     バックスラッシュの2番目の使用法は、出力されない文字を
     パターン内に目に見える形でエンコードする手法を提供するものです。
     パターンを終了させるヌル文字を除き、出力されない文字の見え方に
     は何の制約もありませんが、パターンをテキスト編集する際には、通常
     次のエスケープシーケンスを用いる方が、元のバイナリ文字よりも
     より簡単でしょう。

       \a     アラーム、ベル文字 (16進 07)
       \cx    "control-x", ただし x はあらゆる文字
       \e     エスケープ (16進 1B)
       \f     改ページ (16進 0C)
       \n     改行 (16進 0A)
       \r     復帰 (16進 0D)
       \t     タブ (16進 09)
       \xhh   16進数で hh の文字
       \ddd   8進数で ddd の文字または後方参照

     "\cx" の正確な効果は、次のようになります。"x" が小文字の場合、
     大文字に変換されます。続いて、文字の6ビット目(16進数 40)が
     反転されます。つまり、"\cz" は16進数の 1A になりますが、"\c{" 
     は16進数の 3B になり、"\c;" は 16進数の 7B になります。

     "\x" の後では、2桁の16進数が読まれます。(表す文字は、大文字でも
     小文字でも可です)

     "\0" では2桁までの8進数が読みこまれます。
     両方のケースとも、2桁より少ない場合、表している文字自体が
     使用されます。つまり、"\0\x\07" は2つのヌル文字の後にベル文字
     が続いたものを表します。8進数を表す文字については、最初のゼロ
     の後に2桁の数字を指定するように注意して下さい。

     バックスラッシュの後に0以外の数字が続く場合の処理は、複雑です。
     文字クラスの外では、PCRE は続く桁を10進数として読みこみます。
     数字が10よりも小さい場合、または、式の中に値を取得した左括弧が
     この数以上あった場合、全体のシーケンスは、<emphasis>後方</emphasis> 
     <emphasis>参照</emphasis>として解釈されます。この動作に関する説明
     は、括弧付きのサブパターンの説明の後に行います。

     文字クラスの中または10進数が9より大きく、取得を行ったサブパターン
     がこの数に満たない場合、PCRE はバックスラッシュの後から最大3文字の8進数
     を再度読みこみ、その値の最下位 8ビットから1バイトを生成します。
     続く桁はそれ自体を表します。例えば、

       \040   は空白の別の表記法です
       \40    は、同じ意味です。ただし、値を取得済みのサブパターンが
              40個未満の場合
       \7     は常に後方参照です
       \11    は後方参照またはタブの別の表記法です
       \011   は常にタブです
       \0113  はタブの後に文字 "3" が続いたものです
       \113   (99 を超える後方参照はないので) 8進数 113 を表す文字
       \377   は1ビットの並びで構成される1バイトです
       \81    は後方参照または、ヌル文字の後に2つの文字 "8" および "1" が
              続いたものです。

     3桁を超えて8進数は読みこまれないため、値が100以上の8進数には
     ゼロを前につけるべきではないことに注意してください。

     1バイトの値を定義するあらゆるシーケンスは、文字クラスの内部
     および外部で使用可能です。加えて、文字クラスの内部ではシーケンス
     "\b" はバックスペース(16進 0x)として解釈されます。
     文字クラスの外では、別の意味を有します。(以下を参照下さい)

     バックスラッシュの第3の使用法は、包括的な文字型を指定する用途
     です。

       \d     10進数字
       \D     10進数字でない全ての文字
       \s     空白文字
       \S     空白文字以外の文字
       \w     単語構成文字
       \W     単語構成文字以外

     エスケープシーケンスの各組は、全文字の集合を2つの集合に
     分割します。全ての文字は、各組のうち、片方だ?kマッチします。

     単語構成文字とは英字または数字またはアンダースコア文字であり、
     Perl の "単語" と成り得る文字のことです。
     文字および数字の定義は、PCRE の文字テーブルにより制御され、
     ロケールを指定したマッチを行った場合には変わる可能性があります。
     ("ロケールのサポート"を参照下さい)
     例えば、"fr" (フランス語)ロケールの場合、いくつかの128を超える
     文字コードの文字は、アクセント付きの文字に使用されており、
     これらは \w にマッチします。

     これらの文字型シーケンスは、文字クラスの内外によらず使用可能
     です。これらは、適当な型の1文字にマッチします。現在マッチング
     を行っている位置が検索対象文字列の終端である場合、マッチできる
     文字はないので全てのマッチングは失敗します。

     バックスラッシュの第4の使用法は、単純な言明です。
     言明は、検索対象文字列から文字を全く抜き出さずに
     マッチが特定の位置で生じるという拘束条件を指定します。
     より複雑な言明に関するサブパターンの使用法を以下に説明します。
     バッスラッシュ付きの言明は次のものがあります。

       \b     単語の境界
       \B     単語の境界でない
       \A     検索対象の始まり (複数行モードとは独立)
       \Z     検索対象の終わりまたは終端の改行 (複数行モードとは独立)
       \z     検索対象の終わり (複数行モードとは独立)

     これらの言明は、文字クラスには使用できません。(しかし、文字クラスの
     中では、"\b" には別の意味、つまり、バックスペース文字という意味が
     あることに注意してください)

     単語の境界は、検索対象文字列において、現在の文字および前の文字が
     両方は \w または \W にマッチしない
     (すなわち、片方は \w にマッチして、もう片方は\W にマッチする)か、
     または、最初のまたは最後の文字が \w にマッチするならば、
     それぞれ、文字列の始めまたは終わりの位置です。

     言明 \A, \A, \z は、(以下に説明する)どんなオプションを設定しても
     文字列の始端および終端にのみマッチするハット記号およびドル記号
     とは異なっています。
     これらの言明は、PCRE_NOTBOL または PCRE_NOTEOL オプションの影響を
     受けません。\Z 及び \z の違いは、\Z は、文字列の終端と同時に
     文字列の最後の文字が改行の場合に前の文字にマャÁするのに対し、
     \z は終端にのみマッチします。

ハット記号及びドル記号
     文字クラスの外側の場合、デフォルトのマッチモードでは、ハット記号は
     現在マッチングを行っている位置が対象文字列の始端である場合にのみ
     trueとなる言明です。
     文字クラスの内部では、ハット記号は全く別の意味となります。
     (以下を参照)

     複数の選択肢がある場合、
     ハット記号はパターンの最初の文字である必要はありません。
     しかし、パターンがその枝にマッチしない場合、
     各選択肢の先頭に置く必要があります。
     全ての選択肢がハット記号で始まる場合、パターンは対象の最初にのみ
     マッチするように拘束されてㄣ?場合であり、"アンカー付き" パターンと
     呼ばれます。
     (他の文字もパターンをアンカー付きにすることが可能です)

     ドル記号は、(デフォルトでは)現在のマッチング点が対象文字列の
     終端にあるか、文字列の最後の文字が改行文字である場合に
     その直前にある場合のみ true となる言明です。
     ドル記号は、複数の選択肢がある場合、パターンの最後の文字であ
     る必要はありませんが、使用さ??枝の最後のアイテムである必要
     があります。ドル記号は、文字クラスの中では特別な意味を有しま
     せん。

     ドル記号の意味は、コンパイル時またはマッチング時の
     PCRE_DOLLAR_ENDONLY オプションの設定により
     文字列の終端にのみマッチするように変更することが可能です。
     このせっていは、\Z 言明には影響を与えません。

     ハット記号とドル記号の意味は、PCRE_MULTILINE オプションを設定
     した場合に変化します。これを設定した場合、対象文字列の始端及び
     終端にマッチするのに加えて、文字列内部の "\n" 文字の直前
     及び直後にそれぞれマッチします。例えば、パターン /^abc$/ は
     複数行モードでは対象文字列 "def\nabc" にマッチしますが、
     そうでない場合はマッチしません。結果として、
     全ての枝が "^" で始まるため、単一行モードでアンカー付きのパタ
     ーンは、複数行モードではアンカー無しとなります。
     PCRE_DOLLAR_ENDONLY オプションは、PCRE_MULTILINE が設定されている
     場合は無視されます。

     両方のモードで対象の始端および終端にマッチさせるために
     シーケンス \A, \Z, \z を使用出来ることに注意してください。
     パターンの兣fの枝が \A を付けて始まる場合、
     PCRE_MULTILINE の設定によらず、常にアンカー付きとなります。

終止符 (ピリオド, ドット)
     文字クラスの外側では、パターンの中のドットは非出力文字を含む
     (デフォルトでは)改行以外の対象の全ての1文字にマッチします。
     PCRE_DOTALL オプションを設定した場合、ドットは改行にもマッチ
     します。ドャÈの処理は、ハット記号およびドル記号とは完全お     独立し?Dます。共通な点は共に改行文字を含むことだけです。
     ドットは、文字クラスの中では特別な意味を持ちません。

ブラケット
     左ブラケットは文字クラスの開始を表し、右ブラケットにより終了
     します。右ブラケットは、それ自体特別なものではありません。
     右ブラケットがクラスのメンバーとして必要な場合、(もしあるな
     らば、最初にハット記号を持ってきた後で)クラスの最初の文字デ
     ー?gあるか、バックスラッシュでエスケープする必要があります。

     文字クラスは、対象の1文字にマッチします。その文字はクラスにより
     定義される文字集合の中にある必要があります。ただし、
     クラスの最初の文字がハット記号の場合は、対象文字は暮らすにより
     定義される集合のん課兄あってはなりません。
     ハット記号がクラスのメンバーとして必要な場合は、必ず、最初の
     文字としないか、バックスラッシュでエスケープするようにして下
     さい。

     例えば、文字クラス [aeiou] は小文字の母音にマッチしますが、
     [^aeiou] は小文字の母音以外の文字にマッチします。
     ハット記号は、存在しないものを列挙することによりクラスにある
     文字を指定する便利な表記です。
     ハット記号は、言明ではありません。対象文字列から文字を消費し、
     現在のポインタが文字列の終端にある場合には失敗します。

     大文字小文字を区別しないマッチが行われた場合、クラスの文字は
     大文字・小文字の両方を表します。これは、例えば、大文字小文字
     を区別しない場合のマッチ [aeiou] は "a" と同様に "A" にマッチ
     し、文字小文字を区別しない場合のマッチ [^aeiou] は "A" にマッ
     チしません。一方、大文字小文字を区別する場合はマッチします。

     PCRE_DOTALL または PCRE_MULTILINE オプションをどのように設定
     しようとも改行文字は、文字クラスにおいて特別な方法で処理され
     ません。[^a] のようなクラスは常に改行にマッチします。

     マイナス (ハイフン)文字は文字クラスの中で文字の範囲を指定する
     ために使用されます。例えば、[d-m] は d と m の間のあらゆる
     文字にマッチします。間にナス文字がクラスの中に必要な場合は、
     バックスラッシュでエスケープするか、クラスの最初または最後の
     ような範囲を示すとは解釈されない場所に使用して下さい。
     文字リテラル "]" を範囲の最後の文字として使用することはできま
     せん。[W-]46] のようなパターンは、2つ文字のクラス("W" および
      "-")の後にリテラル文字列 "46]" が続いているクラスとして解釈
     され、"W46]"または "-46]" にマッチします。しかし、範囲の終端
     として解釈される "]" をバックスラッシュでエスケープした場合、
     [W-\]46] は範囲の後に2つの文字が続く一つのクラスとして解釈さ
     れます。"]" の8進あるいは16進表現も範囲の終端として使用可能
     です。

     範囲指定では、ASCII 照合処理を行います。範囲では、[\000-\037]
     のように数値的に指定した文字も使用可能です。文字を含む範囲が
     大文字小文字を区別しないマッチが設定されているときに使用された
     場合、大文字小文字の両方にマッチします。例えば、[W-c] は、
     [][\^_`wxyzabc] に等価であり、大文字小文字に関係なくマッチし
     ます。文字テーブルで "fr" ロケールを使用している場合、
     [\xc8-\xcb] は、大文字小文字の区別無くアクセント付きの E に
     マッチします。

     文字型 \d, \D, \s, \S,  \w,  \W  は文字クラスの中でも指定可能
     であり、クラスにマッチする文字を追加します。例えば、[\dABCDEF]
     は、16進数にマッチします。ハット記号は大文字と組み合わせて
     小文字にマッチング??より範囲の狭い文字集合を簡便に指定する
     ことができます。
     例えば、クラス [^\W_] は文字または数字にマッチしますが、アンダ
     ースコアにはマッチしません。

     \, -, (始端の)^ 以外の全ての英数字でない文字および終端の ] は、
     文字クラスにおいて特別でない文字ですが、エスケープした場合でも
     悪影響はありません。


垂直バー
     垂直バー文字は、選択肢を指定するパターンで使用されます。例えば、パターン

       gilbert|sullivan

     は、"gilbert" または "sullivan" にマッチします。選択肢の数に
     制限はありません。また、選択肢を空とすることが可能です
     (空の文字列にマッチします)。マッチの過程は、各選択肢を左から
     右に逆に行い、最初に成功したものが使用されます。選択肢が(以下
     で説明する)サブパターンの中にある場合、"成功した"ということは
     サブパターンの選択肢と同様にメインパターンの残りの部分もマッチ
     したということを意?Wます。


内部オプション設定
     PCRE_CASELESS, PCRE_MULTILINE,  PCRE_DOTALL, PCRE_EXTENDED の
     設定は、"(?" および ")" で括った Perl オプション文字により
     パターン内部で変更可能です。

       i  PCRE_CASELESS を指定
       m  PCRE_MULTILINE を指定
       s  PCRE_DOTALL を指定
       x  PCRE_EXTENDED を指定

     例えば、(?im) は大文字小文字を区別しない、複数行マッチングを
     指定します。ハイフン文字を前につけることによりそのオプション
     を解除することも可能です。(?im-sx) のように設定と解除を組み合
     わせることも可能です。この場合は、PCRE_CASELESS および 
     PCRE_MULTILINE が設定され、PCRE_DOTALL および PCRE_EXTENDED 
     が解除されます。ある文字がハイフンの前にも後にも指定された
     場合、そのオプションは解除されます。

     オプション変更の適用範囲は設定が行われたパターンの場所に依存
     します。サブパターンの外側で設定された場合、その効果は、オプ
     ションの設定あるいは解除がマッチングの最初で行われたのと同じ
     となります。次のパターンは、全て全く同様に動作します。

       (?i)abc
       a(?i)bc
       ab(?i)c
       abc(?i)

     はコンパイル後のパターンとしては、パターン abc に PCRE_CASELESS
     を設定したものとなり同じになります。言いかえると、このような
     "最上位の"設定は、(サブパターン内部で他の変更を行わない限り)
     パターン全体に適用されます。最上位と同じ設定が複数回行われて
     いる場合、最も右側の設定が使用されます。

     サブパターンの内部でオプションの変更が行われた場合、効果は
     異なります。この動作の変更は、Perl 5.005 で行われました。
     サブパターン内のオプション変更は、それを指定したサブパター
     ンのその部分にのみ影響します。そのため、

       (a(?i)b)c

     は、abc および aBc にマッチし、(PCRE_CASELESS が使用されて
     いないと仮定した場合、)他の文字列にはマッチしません。
     このように、オプションは、パターンの各場所に異なった設定を行う
     ことが可能です。ある選択肢に御こなれた変更は全て、同じサブパ
     ターン内の後に続く枝に波及します。例えば、

       (a(?i)b|c)

     は、"C" にマッチする際に最初の枝がオプション設定前に破棄
     されているにもかかわらず、"ab", "aB", "c", "C" にマッチします。
     これは、オプション設定の効果がコンパイル時に生じることにより
     ます。そうでないと、非常に奇妙なことが生じることになります。

     PCRE 特有のオプション、PCRE_UNGREEDY および PCRE_EXTRA  
    はそれぞれ文字 U および X を使用することにより、Perl 互換の
    オプションと同様に変更することが可能です。
     (?X) フラグの設定は特別で、最上位の場合でも、常にパターン
     内で他の設定をオンにする前に指定する必要があります。
     このフラグは、最初に指定するのが最善です。

サブパターン
     サブパターンは括弧(丸括弧)で区分され、ネストが可能です。
     パターンの一部をサブパターンとして指定するためには、2つのこ
     とを行います。

     1. 選択肢の集合をローカル化します。例えば、パターン

       cat(aract|erpillar|)

     は、単語 "cat",  "cataract",  "caterpillar" にマッチします。
     括弧をつけないと、このパターンは、"cataract",
     "erpillar" または空の文字列にマッチしてしまいます。

     2. 括弧は、サブパターンを(以下で定義する)値を取得するサブパターン
     として設定します。パターン全体がマッチしたサブパターンにマッチ
     した対象文字列の一部は、
     <function>pcre_exec</function> の <emphasis>ovector</emphasis> 
     引数によりコールした側に返されます。値を取得するサブパターンの
     番号を得るために括弧の始まりは(1から始まって)左から右に数えられます。

     例えば、文字列 "the red king" を次のパターンにマッチさせた場合、

       the ((red|white) (king|queen))

     取得される部分文字列は、 "red king", "red",  "king" であり、
     それぞれ 1, 2, 3 番となります。
     
     括弧が2つの昨日を有しているという事実が常に良い方に働くわけで
     はありません。値を取得する必要はないが、サブパターンを複数用
     いることが必要である場合も少なくありません。左括弧の後に "?:"
     を付けた場合、そのサブパターンは値の取得を行わず、値を取得する
     サブパターンの番号を計算する際にも加算されません。例えば、文字列
     "the  white  queen" は次のパターンをマッチさせてみましょう。

       the ((?:red|white) (king|queen))

     取得される部分文字列は、"white queen" と  "queen" であり、
     1番と 2番になります。部分文字列の最大数は99であり、値の取得を
     行うものと行わないものを合わせて全サブパターンの最大数は
     200です。

     便利な略記として、オプションの設定を値を取得しないサブパターンの
     先頭で指定する必要がある場合、オプションの文字を "?" と ":" の
     間に入れることができます。つまり、次の2つのパターン、

       (?i:saturday|sunday)
       (?:(?i)saturday|sunday)

     は全く同じ文字列集合にマッチします。選択肢は左から右に試行さ
     れ、オプションはサブパターンの終端に達するまでリセットされな
     いので、ある枝にあるオプション設定は後に続く枝にも作用します。
     このため、上のパターンは、"Saturday" と同様に"SUNDAY" にも
     マッチします。

繰り返し
     繰り返しは、反復指定子により指定します。次の要素の後に付ける
     ことが出来ます。

       文字またはエスケープされた文字       
       メタ文字 .
       文字クラス
       後方参照 (次の節を参照下さい)
       括弧で括ったサブパターン(言明を除く - 以下を参照下さい)

     通常の反復指定子は、大括弧の中に2つの数をカンマで区切って指定
     することにより、マッチ可能な最小の数と最大の数を指定します。
     指定する数は、65536 未満であり、最初の数は2番目の数以下である
     必要があります。例えば、

       z{2,4}

     は、"zz", "zzz", "zzzz" にマッチします。右括弧はそれ自体特別な
     文字ではありません。2番目の数字が省略されたが、カンマがある場合、
     上限は設定されません。2番目の数字とカンマの両方が省略された場合、
     反復指定子は、必要なマッチの数そのものを指定します。つまり、

       [aeiou]{3,}

     は3回以上母音が続くものにマッチしますが、もっと多い場合にも
     マッチします。一方、

       \d{8}

     は8桁の数字にのみマッチします。左大括弧は反復指定子を置けない
     場所または反復指定子の構文にマッチしない場所に置いた場合、文字
     リテラルとして解釈されます。例えば、{,6} は反復挥Κ子ではなく、
     4つの文字の文字リテラルとなります。

     反復指定子として {0} を指定することができ、前の項目および反復
     指定子が存在しないという式を指定したことになります。

     簡単のため、最も使用される3つの反復指定子には、次のような1文字
     の省略型があります。

       *    は、{0,} と等価です。
       +    は、{1,} と等価です。
       ?    は、{0,1} と等価です。

     反復を設定せず、どの文字にもマッチしない次のようなサブパターンに
     より無限ループを作成することが可能です。

       (a?)*

     以前のバージョンの Perl および PCRE はこのようなパターンに関
     してコンパイル時にエラーを発生していました。しかし、便利な場
     合があるので、このようなパターンは現在は許可されています。
     しかし、他のサブパターンの繰り返しがどの文字にもマッチしない
     場合、ループは強制的に中断されます。

     デフォルトでは、反復指定子は "貪欲"、つまり、残りのパターンを
     失敗させることなく(許可された回数の最大数まで)出来るだけ多く
     のものにマッチします。 この動作が問題を生じる古典的な例としては、
     C プログラムのコメントにマッチさせようとする場合があります。
     コメントは、/* と */ の間にありますが、その中に、独立した文字
      * と / が現れる可能性があります。C のコメントにマッチさせる
      ために、次のパターンを使用してみましょう。

       /\*.*\*/

     を文字列

       /* first command */  not comment  /* second comment */

     に使用した場合、失敗します。これは、.* の貪欲さのせいで指定した
     パターンが文字列全体にマッチしてしまうためです。

     しかし、反復指定子の後に疑問符を続けた場合、貪欲さは消え、
     代わりに最小のマッチを行います。このため、パターン、

       /\*.*?\*/

     はCコメントに正しくマッチします。様々な反復指定子の意味は、
     他には変化せず、好ましいマッチの数だけが変更されます。
     この疑問符の使用法を反復指定子がその?kある場合の使用法と
     こんなランしないようにっf下さい。2稩^の使用法があるので、
     時々、次のように2重に使用されることがあります。

       \d??\d

     選択により1桁の数字にマッチしますが、パターンの残りがマッチ
     する唯一の方法である場合には、2桁の数値にマッチすることが可能です。
     
     PCRE_UNGREEDY オプションが設定された場合(Perl ではこのオプション
     は使用できません)、反復指定子はデフォルトでは貪欲ではありません。
     しかし、この反復指定子は、後ろに疑問符をつけることにより貪欲
     にすることが可能です。言いかえると、疑問符は、デフォルトの動作
     を逆転します。

     括弧で括られたサブパターンが1より多い最小の反復数または最大数
     で指定されている場合、コンパイル済みのパターンのために、最大
     または最小の大きさに応じてより多くの保存領域が必要となります。

     パターンが、.* または .(0,) で始まり、(Perl で等価なものは /s)
     PCRE_DOTALL オプションが設定されている場合、. は改行にマッチ
     できるようになり、パ?üóは暗黙のうちにアンカー付きとなります。
     これは、後ろに続くものによらず、対象文字列の各文字の位置に
     対して試行されるためです。このため、最初にマッチした後で
     どこかの位置で全体のマッチを再び行うことはできません。

     PCRE はこのようなパターンを \A が前にあるものとして処理します。
     対象文字列が改行を含まないことが既知の場合、
     パターンが .* で始まる場合の最適化のためにもしくは ^ を用いて
     アンカーを陽に示すためにPCRE_DOTALL を設定する価値があります。

     値を取得するサブパターンが繰り返される時、取得される値は、
     最後の繰り返しでマッチした部分文字列です。例えば、

       (tweedle[dume]{3}\s*)+

     "tweedledum tweedledee" をマッチさせた場合、取得される部分文
     字列の値は、"tweedledee" です。しかし、ネストされた値を取得
     するサブパターンがある場合、対応する取得値は前の繰り返しで指
     定されたものになる可能性があります。例えば、
       /(a|(b))+/

     を "aba" にマッチさせると、2番目に取得される部分文字列は、
     "b" になります。


後方参照
     文字クラスの外で、バックスラッシュの後に 0 より大きい数字を
     付けたものはパターンで以前に(すなわち左にある)値を取得した
     サブパターンに対する後方参照であり、前にある値の取得を行う
     左括弧の数まで使用可能です。

     しかし、バックスラッシュの後に続く10進数が10未満の場合は常に
     後方参照として解釈され、パターン全体の値を取得する左括弧の数
     に満たない場合にのみエラーとなります。
     言いかえると、参照される括弧は10未満の数については参照する側
     の左にある必要がないということです。
     バックスラッシュの後に数字が続く場合の処理の詳細については、
     上記の "バックスラッシュ"という題の節を参照下さい。

     後方参照は、サブパターン自体がマッチするものよりむしろ、
     現在の対象文字列における値を取得するパターンが実際にマッチし
     たものにマッチします。このため、パターン

       (sens|respons)e and \1ibility

     は、"sense and sensibility" および "response and  responsi-
     bility" にマッチしますが、"sense  and  responsibility" には
     マッチしません。後方参照の時点で、大文字小文字を区別したマッチ
     が有効の場合、文字の大文字小文字が関係します。例えば、

       ((?i)rah)\s+\1

     は、"rah rah" および "RAH RAH" にマッチしますが、
     元の取得したサブパターンは大文字小文字を区別せずマッチしてい
     るにもかかわらず、"RAH  rah" にはマッチしません。

     同じサブパターンに複数回の後方参照を行Fことができます。ある
     サブパターンが特定のマッチで実際には使用されていない場合、
     後方参照は常に失敗します。例えば、パターン

       (a|(bc))\2

     は、"bc" ではなく "a" に最初にマッチする場合に常に失敗します。
     最大 99 個の後方参照を使用できるため、バックスラッシュの後に
     数字が続くものは全て後方参照番号の可能性がある集合として解釈
     されます。
     パターンの後に数字が続く場合、後方参照を終了するために
     なんらかの区切り文字を置く必要があります。
     PCRE_EXTENDED オプションを設定している場合、空白を区切り文字
     とすることができます。その他の場合は空のコメントを使用できます。

     参照する括弧の中にある後方参照は、サブパターンを最初に使用し
     た際に失敗します。このため、(a\1) は何にもマッチしません。
     しかし、このような参照は、複数回使用するサブパターンの内部で
     有用です。例えば、次のパターン

       (a|b\1)+
     
     は、"a" の並び、および "aba"、"ababaa" 等にもマッチします。
     サブパターンの各反復において、後方参照は、前の繰り返しに対応
     する文字列にマッチします。これを動作させるために、最初の反復
     時に後方参照にマッチする必要がないようなパターンである必要が
     あります。これは上の例のように選択を使用するか、ゼロを最小と
     する反復指定子により行うことができます。


言明
     言明は、現在マッチを行っている位置の後に続くか前にある文字に
     対するテストであり、実際には文字への作用を行いません。
     
     \b, \B, \A, \Z, \z, ^, $ のような簡単な言明コードを以下で説
     明します。より複雑な言明は、サブパターンとしてコード化されま
     す。2種類の言明があります。対象文字列において現在位置の前を
     見るものと、後ろを見るものです。

     言明サブパターンは、現在マッチを行っている位置を変更ししない
     ことを除き、通常と同じようにマッチされます。前方への言明は、
     肯定言明の場合 (?= で、否定言明の場合 (?! で始まります。例えば、

       \w+(?=;)

     は、セミコロンが後に続く単語にマッチしますが、マッチするもの
     には、セミコロンを含ません。そして、

       foo(?!bar)

     は、"bar" が後ろに続かない "foo" にマッチします。
     見かけは似ているパターンに注意して下さい。

       (?!foo)bar

     は、"foo" 以外のものが前にある "bar" の存在を見つけられません。
     次の3文字が "bar" である場合に、(?!foo) は常に true となるため
     に、このパターンは、"bar" の存在を見つけることができないのです。
     この動作を実現するためには、後方言明が必要です。
     後方言明は、肯定言明の場合 (?&lt;= で、否定言明の場合 (?&lt;!
     で始まります。例えば、

       (?&lt;!foo)bar

     は、"foo" が前にない "bar" の存在を見つけます。後方言明の内容
     は、マッチする文字列全体が固定長である必要があることに制限さ
     れています。しかし、複数の選択肢がある場合、全ての同じ固定長
     である必要はありません。つまり、

       (?&lt;=bullock|donkey)

     は使用可能ですが、

       (?&lt;!dogs?|cats?)

     はコンパイル時にエラーを生じます。異なった長さの文字列にマッ
     チする枝は、後方言明の最上位でのみ使用可能です。この機能は、
     全ての枝の同じ長さの文字列にマッチする必要がある Perl 5.005 
     に対して拡張されています。次のような言明

       (?&lt;=ab(c|de))

     は、最上位の枝が2つの異なった長さにマッチし得るため、使用でき
     ません。しかし、最上位の枝を2つ使用するように書き換えた場合は、
     使用可能です。

       (?&lt;=abc|abde)

     後方言明の実装においては、選択肢毎に一時的に固定の幅だけ現在の
     位置を後退し、マッチを試みます。現在位置の前に十分な文字がない
     場合は、マッチは失敗とみなされます。1度しか使用されないサブパ
     ターンと組み合わせた後方言明は、文字列の終端でのマッチングに
     特に有用です。節の最後に1度だけ使用するサブパターンの例を示し
     ます。

     (あらゆる種類の)複数の言明を連続して指定することも可能です。
     例えば、

       (?&lt;=\d{3})(?&lt;!999)foo

     は前に "999" でない3桁の数字がある "foo" にマッチします。
     更に、言明は、自由に組み合わせてネストさせることが可能です。
     例えば、

       (?&lt;=(?&lt;!foo)bar)baz

     は、"bar" が前にあり、逆に "foo" が前にない "baz" にマッチします。

     言明のサブパターンは値を取得するサブパターンではなく、繰り
     返されないかもしれません。それは、同じことを複数回言明するの
     は意味がないからです。ある言明が値を取得するサブパターンを
     中に含んでいる場合、パターン全体の中で値を取得するサブパター
     ンを数えるために常に数え上げられます。
     取得した部分文字列は、肯定言明では使用されますが、否定言明
     では意味を持ちません。

     言明の括弧で括られたサブパターンの数は、最大 200 です。


一回だけ使用するサブパターン
     反復を最大化および最小化する場合は共に、後に続くものへのマッ
     チが失敗した場合、反復数を変えた場合にパターンの残りにマッチ
     することができるかどうかを調べるために反復する項目が再評価さ
     れます。

     時々、こうした動作を行わない方が便利なことがります。
     それは、パターンの作者が続けていく価値がないとわかった時に
     マッチの特性を変更するか、他のことがおきるよりも前に失敗させ
     る場合です。

     例えば、パターン \d+foo を次の対象に適用した場合を考えてみま
     しょう。

       123456bar

     6桁の数字にマッチした後、"foo" にマッチするのに失敗します。
     マッチ処理の通常の動作では、5桁の数字のみが \d+ にマッチする
     としてで再度試行を行い、続いて 4 桁といったように完全に失敗
     するまで試行を行います。使い捨てのサブパターンは、
     パターンの一部が一回マッチしたら、再評価されないことを指定す
     るものです。このため、最初に "foo" へのマッチに失敗した時点
     で、ただちにマッチがとりやめられます。
     表記には、次の例のように (?&gt; で始まる別の特別な括弧を用い
     ます。

       (?&gt;\d+)bar

     この種類の括弧は、一回マッチが行われたパターンの一部に鍵をか
     け、そのパターンへの再マッチは失敗します。
     しかし、マッチに成功する前の再マッチは、通常と同様に動作しま
     す。

     この型のサブパターンは、対象文字列の現在の点にアンカーがある
     場合、同じ孤立したパターンがマッチする文字列にマッチするとい
     うようにも説明できます。

     使い捨てのサブパターンは、サブパターンの値を取得しません。
     上の例のように簡単な場合は、できるだけ多くのものを呑み込む
     よう反復を最大化すると考えられます。
     このため、\d+ および \d+? が数字の数を調整しつつ残りのパターン
     がマッチするようマッチを繰り返すのに大して、(?&gt;\d+) は
     数字の並び全体にマッチにのみマッチが可能です。

     この構造は、任意の複雑なサブパターンを含むことができ、ネスト
     することが可能です。

     使い捨てのサブパターンは、文字列の終端に対するマッチを効率的
     に指定するために後方言明を組み合わせて使用できます。次の簡単
     なパターンを見てましょう。

       abcd$

     マッチしない長い文字列に適用した場合を考えます。
     マッチは左から右に行われるため、PCRE は対象の "a" を探し、
     後にあるものがパターンの残りにマッチするかどう??調べます。
     パターンが次のように指定された場合、

       ^.*abcd$

     最初の .* はまず文字列全体にマッチしますが、これに失敗した場
     合、最後の文字以外の全てのものにマッチするよう再度マッチを
     行い、続いて最後の2文字以外という風に動作します。
     "a" の検索を文字列全体に対して左から右に再度行うため、
     効率は良くありません。しかし、パターンを次のよ?k書いた場合、

       ^(?&gt;.*)(?&lt;=abcd)

     この場合は、.* に関する再検索は行われず、文字列全体にのみマッ
     チします。続く後方言明は、最後の4文字に対する試行を1回だけ行
     います。これが失敗した場合、マッチはただちに失敗します。長い
     文字列の場合、この方法による実行時間にはかなりの差が生じます。

条件付きサブパターン
     言明の結果または前の値を取得するサブパターンがマッチしたかど
     うかにより、サブパターンのマッチ処理を行ったり、サブパターンの
     2つの選択肢を選択したりすることが可能です。条件付きサブパター
     ンには2つの形式があります。

       (?(condition)yes-pattern)
       (?(condition)yes-pattern|no-pattern)

     条件が満たされた場合、yes-pattern が使用されます。そうでない
     場合は、(指定された場合は) no-pattern が使用されます。サブパ
     ターンに2つ以上の選択肢がある場合、コンパイル時にエラーになり
     ます。

     2種類の条件があります。括弧の間のテキストが数字の並びからなる
     場合、条件は、その番号の値を取得したサブパターンが前にマッチ
     している場合に満たされます。次のパターンを見てみましょう。
     可読性を高めるために意味のない空白を挿入し(PCRE_EXTENDED 
     オプションが指定されたと仮定します)、説明を簡単にするため
     3つの部分に分割しています。

       ( \( )?    [^()]+    (?(1) \) )

     最初の部分は、オプションの左括弧にマッチし、その文字がある場
     合に、最初の部分文字列として設定します。第2の部分は、括弧以外
     の一つ以上の文字にマッチします。第3の部分は、最初の括弧にマッ
     チしたかどうKを調べる条件ۘサブパターンです。マッチしている
     場合、つまり、対象が左括弧で始まっている場合、条件はtrueと
     なり、yes-pattern が実行され、右括弧が必要となります。
     そうでない場合、no-pattern が存在しないため、サブパターンは
     何にもマッチしません。言いかえると、このパターンは、括弧なし
     の並びにマッチし、オプションで括弧で囲まれた並びにマッチします。

     条件が数字の並っg内4合、言明となります。肯定あるいは否定の
     前方または後方言明となります。次のパターンを見てみましょう。
     このパターンにも意味のないパターンを挿入し、2つの選択肢を2行
     目に置いています。

       (?(?=[^a-z]*[a-z])
       \d{2}[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )

     条件は、肯定後方言明であり、英字以外の文字の並びかその後に
     英字が続くものにマッチします。言いかえると、対象文字列に少な
     くとも文字が一つあるかどうかを調べます。文字がみつかると、
     検索対象は最初の選択肢に対してマッチします〣]うgない場合
     は、2番目にマッチします。このパターンは、2つの形式 dd-aaa-dd
     または dd-dd-dd のどちらかの文字列にマッチします。ただし、
     aaa は英字、dd は数字です。

コメント
     (?# という並びは、開始を指定します。コメントは、次の右括弧まで
     続きます。括弧のネストは許可されません。コメント中の文字は、
     パターンマッチングには全く関係しません。

     PCRE_EXTENDED オプションが設定されている場合、文字クラスの外
     にあるエスケープされていない # 文字は、コメントを指定します。
     コメントは、パターン中の次の改行文字まで続きます。

性能
     パターンの幾つかの要素は、他の要素よりもより効率的です。
     (a|e|i|o|u) のような選択肢の集合よりも [aeiou] のような文字ク
     ラスの方がより効率的です。一般に、構成が最も簡単なものが
     たいてい最も効率が良いです。Jeffrey Friedl の本には、
     性能向上のために正規表現の最適化に関する多くの議論が
     記述されています。

     パターンが .* で始まり、PCRE_DOTALL オプションが設定されている
     場合、対象文字列の始端でしかまっちできないため、パターンは 
     PCRE により暗黙のうちにアンカー付きとなります。
     しかし、PCRE_DOTALL が設定されていない場合、メタ文字 . が
     改行にマッチしないので、PCREはこの最適化を行えません。
     対象文字列が改行を含む場合、パターンは文字列の始端からではなく
     各改行の直後の文字からマッチする可能性があります。例えば、
     パターン

        (.*) second

     は、対象文字列 "first\nand second" (ただし、\n は改行文字を
     意味します) にマッチします。
     最初に値を取得される部分文字列は、"and" になります。これを動
     作させるには、PCRE は対象文字列の各改行の後からマッチを再度
     開始する必要があります。

     このようなパターンを改行を含まない対象文字列に使用した場合、
     PCRE_DOTALL を設定するか、アンカー付きであることを陽に示すため
     にパターンを ^.* で開始することにより最高の性能が得られます。
     これにより、PCRE が対象文字列の改行を探し、そこで再スタート
     することを防止します。
    </literallayout>
   </refsect1>
  </refentry>
</reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
