<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 1e46ca946428a63404e5f9ed32f59cc81c1fc694 Maintainer: takagi Status: working -->

<section xml:id="mongo.tutorial" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>チュートリアル</title>
 <section>
  <title>導入</title>
  <para>
   これは、10gen がサポートする MongoDB 用 PHP ドライバです。
  </para>
  <para>
   簡単なコード例をもとに、MongoDB への接続やドキュメントの追加、
   ドキュメントの問い合わせ、問い合わせ結果の反復処理、
   そして接続の切断の方法を示します。
   各ステップの詳細については後に続くチュートリアルを参照ください。
  </para>
  <programlisting role="php">
<![CDATA[
<?php

// 接続
$m = new Mongo();

// データベースの選択
$db = $m->comedy;

// コレクション (リレーショナルデータベースのテーブルみたいなもの) の選択
$collection = $db->cartoons;

// レコードの追加
$obj = array( "title" => "Calvin and Hobbes", "author" => "Bill Watterson" );
$collection->insert($obj);

// 構造が異なる別のレコードの追加
$obj = array( "title" => "XKCD", "online" => true );
$collection->insert($obj);

// コレクション内の全件の検索
$cursor = $collection->find();

// 結果の反復処理
foreach ($cursor as $obj) {
    echo $obj["title"] . "\n";
}

?>
]]>
  </programlisting>
  <para>
   この出力は、次のようになります。
  </para>
  <screen>
<![CDATA[
Calvin and Hobbes
XKCD
]]>
  </screen>
 </section>
 <section>
  <title>接続の作成</title>
  <para>
   データベースサーバに接続するには、次のいずれかの方法を使います。
  </para>

  <programlisting role="php">
<![CDATA[
<?php

$connection = new Mongo(); // localhost:27017 に接続します
$connection = new Mongo( "example.com" ); // リモートホスト (デフォルトのポート: 27017) に接続します
$connection = new Mongo( "example.com:65432" ); // リモートホストの指定したポートに接続します

?>
]]>
  </programlisting>
  <para>
   You do not have to explicitly disconnect from the database.  When
   <literal>$connection</literal> goes out of scope, the connection will be
   closed automatically and any database resources it was using will be freed.
  </para>
  <section>
   <title>See Also</title>
   <para>
    The chapter on <link linkend="mongo.connecting">connecting</link>
    covers different types of connections.
   </para>
   <para>
    The API documentation on the <classname>Mongo</classname> class and
    <function>Mongo::__construct</function> give a comprehensive look at all
    possible options with a number of examples.
   </para>
  </section>

  <section>
  <title>データベースの取得</title>
   <para>
    データベースを選択するには次のようにします。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db = $connection->dbname;

?>
]]>
   </programlisting>
   <para>
    データベースを事前に作っておく必要はありません。
    存在しないデータベースを選択すれば、新しいデータベースを作ることができます。
   </para>
   <para>
    Typo には注意しましょう! 意図せずに新しいデータベースを作ってしまい、
    エラーで悩まされる原因になります。

    <programlisting role="php">
<![CDATA[
<?php

$db = $connection->mybiglongdbname;
// 何かをします
$db = $connection->mybiglongdbanme;
// これは別のデータベースに接続してしまいます!

?>
]]>
    </programlisting>
   </para>
   <section>
    <title>See Also</title>
    <para>
     The API documentation on the <classname>MongoDB</classname> class contains
     more information about database objects.
    </para>
   </section>
  </section>

  <section>
   <title>コレクションの取得</title>
   <para>
    コレクションの取得は、データベースの取得と同じ構文で行えます。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db = $connection->baz;
$collection = $db->foobar;

// あるいは、もうすこし簡潔に
$collection = $connection->baz->foobar;

?>
]]>
   </programlisting>
   <para>
    A collection is analogous to a table (if you are familiar with relational
    databases).
   </para>
   <section>
    <title>See Also</title>
    <para>
     The API documentation on the <classname>MongoCollection</classname> class
     contains more information about collection objects.
    </para>
   </section>
  </section>

  <section>
   <title>ドキュメントの追加</title>
   <para>
    連想配列は、データベース内のコレクションに保存できる基本的なオブジェクトです。
    何らかの "ドキュメント" はこのような形式になります。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$doc = array( "name" => "MongoDB",
   "type" => "database",
   "count" => 1,
   "info" => (object)array( "x" => 203, "y" => 102),
   "versions" => array("0.9.7", "0.9.8", "0.9.9")
);

?>
]]>
   </programlisting>
   <para>
    配列やオブジェクトをネストできることに注目しましょう。
   </para>
   <para>
    ドキュメントを追加するには <function>MongoCollection::insert</function> を使います。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$collection->insert( $doc );

?>
]]>
   </programlisting>
   <section>
    <title>See Also</title>
    <para>
     The API documentation on <function>MongoCollection::insert</function>
     contains more information about inserting data.
    </para>
   </section>
  </section>

  <section>
   <title>
    <function>MongoCollection::findOne</function> によるドキュメントの検索
   </title>
   <para>
    To show that the document we inserted in the previous step is there, we can
    do a simple <function>MongoCollection::findOne</function> operation to get a
    single document from the collection. This method is useful when there only is
    one document matching the query or you are only interested in one result.
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$obj = $collection->findOne();
var_dump( $obj );

?>
]]>
   </programlisting>
   <para>
    結果は、このようになります。
   </para>
   <programlisting>
<![CDATA[
array(6) {
  ["_id"]=>
  object(MongoId)#8 (1) {
    ["$id"]=>
    string(24) "4e2995576803fab768000000"
  }
  ["name"]=>
  string(7) "MongoDB"
  ["type"]=>
  string(8) "database"
  ["count"]=>
  int(1)
  ["info"]=>
  array(2) {
    ["x"]=>
    int(203)
    ["y"]=>
    int(102)
  }
  ["versions"]=>
  array(3) {
    [0]=>
    string(5) "0.9.7"
    [1]=>
    string(5) "0.9.8"
    [2]=>
    string(5) "0.9.9"
  }
}
]]>
   </programlisting>
   <para>
    Note that there is an <literal>_id</literal> field that has been added
    automatically to your document. <literal>_id</literal> is the "primary key"
    field.  If your document does not specify one, the driver will add one
    automatically.
   </para>
   <para>
    If you specify your own <literal>_id</literal> field, it must be unique to
    the collection.  See the example here:
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$db->foo->insert(array("_id" => 1), array("safe" => true));
// this will throw an exception
$db->foo->insert(array("_id" => 1), array("safe" => true));

// this is fine, as it is a different collection
$db->bar->insert(array("_id" => 1), array("safe" => true));

?>
]]>
   </programlisting>
   <para>
    Note that these inserts pass a second array:
    <literal>array("safe" => true)</literal>.  This second field specifies
    options for the insert.  By default, the driver does not wait for a database
    response for writes, so the driver would not catch the the
    <literal>_id</literal>.  As we specify that this is a "safe" write, the
    driver will wait for a database response and see that the write did not go
    through.  In general, all writes should use the "safe" option (it is omitted
    in previous examples for simplicity).
   </para>
   <section>
    <title>See Also</title>
    <para>
     <function>MongoCollection::findOne</function> for more information about
     finding data.
    </para>
    <para>
     <classname>MongoId</classname> goes into more detail on unique ids.
    </para>
    <para>
     The <link linkend="mongo.writes">writes</link> section covers safe
     writes in more depth, as do the writing functions such as
     <function>MongoCollection::insert</function>,
     <function>MongoCollection::update</function>, and
     <function>MongoCollection::remove</function>.
    </para>
   </section>
  </section>

  <section>
   <title>複数のドキュメントの追加</title>
   <para>
    もう少し意味のある問い合わせをするために、複数のシンプルなドキュメントをコレクションに追加しましょう。
    These documents will just be of the form
    <literal>array( "i" => <replaceable>value</replaceable> );</literal> and we
    can do this fairly efficiently in a loop:
   </para>
   <programlisting role="php">
<![CDATA[
<?php

for($i=0; $i<100; $i++) {
    $collection->insert( array( "i" => $i ) );
}

?>
]]>
   </programlisting>

   <para>
    先ほどと同じコレクションに、別のキーを持つ配列を追加していることに注目しましょう。
    MongoDB が「スキーマフリー」であると言われるのは、こういう側面があるからです。
   </para>
  </section>

  <section>
   <title>コレクション内のドキュメント数</title>
   <para>
    これで 101 件のドキュメントを追加したことになります
    (先ほどのループで 100 件、そして最初の 1 件)。
    本当にそうなっているか、<function>MongoCollection::count</function> メソッドで確認してみましょう。
    <programlisting role="php">
<![CDATA[
<?php

echo $collection->count();

?>
]]>
    </programlisting>
    結果は 101 と表示されます。
   </para>
  </section>

  <section>
   <title>カーソルを使った全ドキュメントの取得</title>
   <para>
    コレクション内のすべてのドキュメントを取得するには
    <function>MongoCollection::find</function> を使います。
    find() メソッドは <classname>MongoCursor</classname> オブジェクトを返し、
    これを使うとクエリにマッチしたドキュメントすべてに対する反復処理ができるようになります。
    では、すべてのドキュメントを取得して表示させてみましょう。

    <programlisting role="php">
<![CDATA[
<?php

$cursor = $collection->find();
foreach ($cursor as $id => $value) {
    echo "$id: ";
    var_dump( $value );
}

?>
]]>
    </programlisting>

    これは、コレクション内の全 101 ドキュメントを表示します。
    <literal>$id</literal> はドキュメントの <literal>_id</literal> フィールドで、
    <literal>$value</literal> はドキュメントそのものです。
   </para>
   <section>
    <title>See Also</title>
    <para>
     The API documentation on <function>MongoCollection::find</function>
     contains more information about finding data.
    </para>
   </section>
  </section>

  <section>
   <title>問い合わせの条件の設定</title>
   <para>
    クエリを作って <function>MongoCollection::find</function> メソッドに渡せば、
    コレクション内のドキュメントのサブセットを取得することができます。
    たとえば、"i" フィールドの値が 71 であるドキュメントを探したいときは、
    このようにします。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => 71 );
$cursor = $collection->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    そうすると、ひとつのドキュメントだけが表示されます。
   </para>
   <programlisting>
<![CDATA[
array(2) {
  ["_id"]=>
  object(MongoId)#6 (0) {
  }
  ["i"]=>
  int(71)
  ["_ns"]=>
  "testCollection"
}
]]>
   </programlisting>
  </section>

  <section>
   <title>クエリによる複数ドキュメントの取得</title>
   <para>
    クエリを使って、コレクションからドキュメントのセットを取得することができます。
    たとえば、"i" &gt; 50 であるすべてのドキュメントを取得したい場合は次のようにします。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => array( '$gt' => 50 ) ); // '$gt' と、シングルクォートで囲んでいることに注意しましょう
$cursor = $coll->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    これは、i &gt; 50 であるドキュメントをすべて表示します。
    また、20 &lt; i &lt;= 30 のような範囲を指定することもできます。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$query = array( "i" => array( "\$gt" => 20, "\$lte" => 30 ) );
$cursor = $coll->find( $query );

while( $cursor->hasNext() ) {
    var_dump( $cursor->getNext() );
}

?>
]]>
   </programlisting>
   <para>
    Remember to always escape the $-symbol or use single quotes.  Otherwise PHP
    will interpret it to be the variable <varname>$gt</varname>.
   </para>
  </section>

  <section>
   <title>インデックスの作成</title>
   <para>
    MongoDB はインデックスをサポートしています。コレクションにインデックスを追加するのは簡単です。
    インデックスを作るには、対象となるフィールドと並び順を指定します。
    並び順は、昇順 (1) あるいは降順 (-1) のいずれかです。
    この例では、"i" フィールドの昇順でインデックスを作成しています。
   </para>
   <programlisting role="php">
<![CDATA[
<?php

$coll->ensureIndex( array( "i" => 1 ) );  // "i" にインデックスを作ります
$coll->ensureIndex( array( "i" => -1, "j" => 1 ) );  // "i" の降順、"j" の昇順でインデックスを作ります

?>
]]>
   </programlisting>
   <para>
    Indexing is critical for good read performance as your data grows.  If you
    are not familiar with indexing, check out the
    <function>MongoCollection::ensureIndex</function> documentation and the core
    <link xlink:href="&url.mongodb.dochub.indexes;">MongoDB indexing documentation</link>.
   </para>
  </section>
 </section>
</section>
