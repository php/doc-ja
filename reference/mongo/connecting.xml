<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 06c28576dfb94c76e1a0b18b686207bab70b6978 Maintainer: takagi Status: working -->

<section xml:id="mongo.connecting" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>接続</title>

 <para>
  MongoDB への接続は単に <literal>new Mongo</literal> とするだけの簡単なものですが、
  オプションや設定項目が多数あります。
  <function>Mongo::__construct</function> のページにすべての API
  オプションをまとめましたが、ここではより実用的な使用例とアドバイスをとりあげます。
 </para>

 <section>
  <title>接続時のログイン</title>
  <para>
   MongoDB を <literal>--auth</literal> あるいは
   <literal>--keyFile</literal> オプションつきで起動すると、
   まずログインしないとドライバを使った操作ができなくなります。
   接続にログインするには、ユーザ名とパスワードを接続 URI に指定します。
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$m = new Mongo("mongodb://${username}:${password}@localhost");

?>
]]>
  </programlisting>
  <para>
   接続が落ちると、ドライバが自動的に再接続と再認証を試みます。
  </para>
  <para>
   データベースレベルでの認証には
   <function>MongoDB::authenticate</function> を使います。
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$m = new Mongo();
$db = $m->admin;

$db->authenticate($username, $password);

?>
]]>
  </programlisting>
  <para>
   この方式には大きな問題があります。データベース接続が落ちて再接続したときには、
   新しい接続はまだ認証されていない状態になるということです。
   URI 形式を使えば、新しい接続が立ち上がったときに PHP ドライバが自動的に認証を試みます。
  </para>
  <para>
   別のデータベースに対して認証を試みるには、データベース名をホスト名の後に指定します。
   この例では、"blog" データベースにログインしています。
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$m = new Mongo("mongodb://${username}:${password}@localhost/blog");

?>
]]>
  </programlisting>
 </section>

 <section>
  <title>レプリカセット</title>
  <para>
   レプリカセットに接続するには、セットに属するサーバをひとつ以上指定して、
   さらに <literal>replicaSet</literal> オプションを使います。
  </para>
  <programlisting role="php">
<![CDATA[
<?php

$m = new Mongo("mongodb://localhost:27017", array("replicaSet" => "myReplSetName"));

?>
]]>
  </programlisting>
  <para>
   バージョン 1.0.9 以降のドライバでは、レプリカセットへの接続が必須となります
   (それより前のバージョンでは、マスタの自動検出や再接続が正しく動作しません)。
  </para>
  <para>
   PHP ドライバは、指定したサーバ群に問い合わせてどれがマスタなのかを調べます。
   リストにあげたサーバのうち少なくともひとつに接続でき、
   マスタが見つかってさえいれば接続が成功したとみなされます。
   どのサーバにも接続できない、あるいはマスタが見つからないといった場合は
   <classname>MongoConnectionException</classname> がスローされます。
  </para>
  <para>
   マスタが使えなくなったときに、スレーブがマスタになるには数秒かかります。
   その間は、この接続では一切のデータベース操作ができなくなります
   (スレーブに接続して読み込みを行うことは可能です)。
   したがって、このときに何らかの読み書き操作をすると例外が発生します。
  </para>
  <para>
   新しいマスタが選ばれると、読み込みや書き込みの操作時にドライバが新しいマスタを検出できるようになります。
   そして、ドライバがデータベース接続を切り替えて通常の操作を続行できるようになります。
  </para>
  <para>
   レプリカセットについての詳細は、
   <link xlink:href="&url.mongodb.replica;">コアドキュメント</link>
   を参照ください。
  </para>
 </section>

 <section>
  <title>ドメインソケットのサポート</title>

  <para>
   MongoDB をローカルで動かしていてバージョン 1.0.9
   以降のドライバを使っている場合は、ファイル経由でデータベースに接続することができます。
   MongoDB は、起動時に自動的にソケットファイル
   /tmp/mongodb-&lt;port&gt;.sock をオープンします。
  </para>

  <para>
   ソケットファイルに接続するには、このパスを MongoDB 接続文字列に指定します。
  </para>

  <programlisting role="php">
<![CDATA[
<?php

$m = new Mongo("mongodb:///tmp/mongo-27017.sock");

?>
]]>
  </programlisting>

  <para>
   上で示したようなソケットファイルへの接続で認証を使いたい場合は、
   ポート番号 0 を指定しなければなりません。
   接続文字列のパーサは、これを接続文字列の終端と見なします。
  </para>

  <programlisting role="php">
<![CDATA[
<?php

$m = new Mongo("mongodb://username:password@/tmp/mongo-27017.sock:0/foo");

?>
]]>
  </programlisting>

 </section>

 <section>
  <title>接続プーリング (バージョン 1.2.0 以降)</title>
  <para>
   接続の作成は、ドライバが行う作業の中でも最も重量級の作業です。
   接続を正しく確立するには、どんなに高速なネットワークであっても数百ミリ秒はかかることがあります。
   そこで、ドライバが新たな接続を作る回数をできるだけ減らすために、
   プールにある接続を再利用することを考えます。
  </para>
  <para>
   ユーザが新しい <classname>Mongo</classname> のインスタンスを作ると、
   必要な接続はすべて接続プールから取り出します (レプリカセットへの接続には
   複数の接続が必要となることもあります。それぞれが、セット内の個々のメンバーへの接続となります)。
   <classname>Mongo</classname> のインスタンスがスコープ外に出ると、接続をプールに返します。
   PHP のプロセスが終了すると、プール内のすべての接続が閉じられます。
  </para>
  <section>
   <title>"Why do I have so many open connections?"</title>
   <para>
    Connection pools can generate a large number of connections. This is expected
    and, using a little arithmetic, you can figure out how many connections to
    expect.  There are three factors in the total number of connections:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>
       connections_per_pool
      </literal>
     </para>
     <para>
      Each connection pool will create, by default, an unlimited number of
      connections. One might assume that this is a problem: if it can create an
      unlimited number of connections, couldn't it create thousands and the
      server would run out of file descriptors? In practice, this is unlikely,
      as unused connections are returned to the pool to be used later, so future
      connections will use the same connection instead of creating a new one.
      Unless you create thousands of connections at once without letting any go
      out of scope, the number of connections open should stay at a reasonable
      number.
     </para>
     <para>
      You can see how many connections you have in a pool using the
      <function>MongoPool::info</function> function.  Add up the "in use" and
      "in pool" fields for a given server.  That is the total number of
      connections for that pool.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>
       pools_per_process
      </literal>
     </para>
     <para>
      Each MongoDB server address you're connecting to gets its own connection
      pool.  For example, if your local hostname is "example.net", connecting
      to "example.net:27017", "localhost:27017", and "/tmp/mongodb-27017.sock"
      will create three connection pools.  You can see how many connection pools
      you have open using <function>MongoPool::info</function>.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>
       processes
      </literal>
     </para>
     <para>
      Each PHP process has a separate set of pools.  PHP-FPM and Apache
      generally create between 6 and a couple dozen PHP worker children. Check
      your settings to see what the max number of PHP processes is that can be
      spawned.
     </para>
     <para>
      If you are using PHP-FPM, estimating the number of connections can be
      tricky because it will spawn more PHP-FPM workers under heavy load. To be
      on the safe side, look at the max_children parameter or add up
      spare_servers+start_servers (choose whichever number is higher).  That's
      how many PHP processes (and, thus sets of pools) you should plan for.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    The three variables above can be multiplied together to give the max
    number of connections expected:
    <literal>connections_per_pool*pools_per_process*processes</literal>.  Note
    that <literal>connections_per_pool</literal> can be different for different
    pools, so <literal>connections_per_pool</literal> should be the max.
   </para>
   <para>
    For example, suppose we're getting 30 connections per pool, 10 pools per PHP
    process, and 128 PHP processes.  Then we can expect 38400 connections from
    this machine.  Thus, we should set this machine's file descriptor limit to
    be high enough to handle all of these connections or it may run out of file
    descriptors.
   </para>
   <para>
    See <classname>MongoPool</classname> for more information on connection
    pooling.
   </para>
  </section>
 </section>

 <section>
  <title>持続的接続</title>
  <note>
   <para>
    この節は 1.2.0 以降のバージョンには関係ありません。
    1.2.0 以降、接続は常に持続的なものとなり、
    ドライバが自動管理するようになりました。
    プーリングに関する詳細な情報は <classname>MongoPool</classname> を参照ください。
   </para>
  </note>

  <para>
   データベースへの接続を新たに確立させるには、非常に時間がかかります。
   データベースへ接続の作成回数を最小限にするには、持続的接続を使うことができます。
   持続的接続は PHP が保持するので、同じ接続を使って複数のリクエストを送ることができます。
  </para>

  <para>
   たとえば、この単純なプログラムはデータベースに 1000 回接続します。
  </para>

  <programlisting role="php">
<![CDATA[
<?php

for ($i=0; $i<1000; $i++) {
  $m = new Mongo();
}

?>
]]>
  </programlisting>

  <para>
   実行時間は約 18 秒です。これを、持続的接続を使うように変更してみましょう。
  </para>

  <programlisting role="php">
<![CDATA[
<?php

for ($i=0; $i<1000; $i++) {
  $m = new Mongo("localhost:27017", array("persist" => "x"));
}

?>
]]>
  </programlisting>

  <para>
   実行時間は .02 秒未満になりました。データベースへの接続は 1 回だけしか行わないからです。
  </para>

  <para>
   持続的接続には識別用の文字列 (上の例では "x")
   が必要で、これを使って接続を識別します。
   持続的接続を使うには、ホスト名とポート、持続文字列、そしてユーザ名とパスワード(指定した場合)
   が既存の持続的接続と一致しなければなりません。
   一致しない場合は、この識別情報で新しい接続を作成します。
  </para>
  <para>
   持続的接続を使うことを<emphasis>強く推奨します</emphasis>。
   実運用環境では、やむを得ぬ理由がない限り常に持続的接続を使うべきです。
   リレーショナルデータベースにおいて持続的接続を推奨しない理由はいくつかありますが、
   その大半は MongoDB には無関係なものです。
  </para>
 </section>

</section>
