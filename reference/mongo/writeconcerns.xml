<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 8915e3eac5b5d0b968bce6241891018dd41648bd Maintainer: takagi Status: ready -->

<chapter xml:id="mongo.writeconcerns" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>書き込み確認</title>

 <para>
  MongoDB では、書き込みをデータベースに永続化させるための方法を選べます。
  この方法のことを <literal>書き込み確認 (Write Concern)</literal> と呼びます。
  あらゆるエラーを無視することもできるし、
  特定のサーバーへの書き込みを確認するまで書き込み完了と見なさないようにもできます。
 </para>
 <para>
  書き込み操作 (<methodname>MongoCollection::insert</methodname> や
  <methodname>MongoCollection::update</methodname>、
  <methodname>MongoCollection::remove</methodname>) で Write Concern オプション
  (<literal>"w"</literal>) を指定すると、ドライバはクエリを MongoDB
  に送信してから <literal>getLastError</literal> コマンド
  (<acronym>GLE</acronym>) に Write Concern オプションを付けて実行します。
  これは Write Concern 条件を満たすかタイムアウト
  (<literal>"wtimeout"</literal> で指定でき、デフォルトは <literal>10000</literal> ミリ秒)
  に達するまでブロックします。
 </para>

 <warning>
  <para>
   <literal>getLastError</literal> コマンドがタイムアウトしたとしても、
   ほとんどの場合はデータはプライマリサーバーに書き込まれており、
   そのうちにすべてのセカンダリにレプリケートされるでしょう。
  </para>
  <para>
   タイムアウトの発生要因として一番ありがちなのは、
   書き込み確認を指定するときに現在使えるサーバー数よりも大きなサーバー数を指定したというものです。
  </para>
 </warning>

 <para>
  書き込み確認を使っているときにレプリカセットのフェイルオーバーが発生すると、
  ドライバは自動的にプライマリとの接続を切断して例外をスローし、
  次の操作のときに新しいプライマリを探そうとします
  (新しいプライマリでもう一度操作をやり直すかそうしないかは、
  アプリケーション側で決めないといけません)。
 </para>
 <para>
  書き込み確認をしない (w=0) の場合にレプリカセットのフェイルオーバーが発生すると、
  ドライバ側でそれを知る手段がありません。そのため、何も気づかずに操作を続け、
  結果的に書き込みは失敗してしまいます。
 </para>
 <para>
  <classname>MongoClient</classname> でのデフォルトの書き込み確認は
  <literal>1</literal> になっており、書き込み完了を確認するようになっています。
 </para>


 <para>
  <table xml:id="mongo.writeconcerns.options">
   <title>利用可能な書き込み確認オプション</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>書き込み確認</entry>
      <entry>意味</entry>
      <entry>説明</entry>
     </row>
    </thead>
    <tbody>
<!--
     <row>
      <entry>w=-1</entry>
      <entry>Errors ignored</entry>
      <entry>No errors, including network errors, will be checked at all</entry>
     </row>
-->
     <row>
      <entry>w=0</entry>
      <entry>確認しない</entry>
      <entry>書き込みの後に <acronym>GLE</acronym> を呼びません。つまり、何もチェックしません ("投げっぱなし/fire and forget")</entry>
     </row>
     <row>
      <entry>w=1</entry>
      <entry>確認する</entry>
      <entry>サーバー (レプリカセット構成の場合はプライマリ) に書き込まれたことを確認します。</entry>
     </row>
     <row>
      <entry>w=N</entry>
      <entry>レプリカセットで確認する</entry>
      <entry>プライマリに書き込まれ、そしてそれが <literal>N-1</literal> のセカンダリにレプリケートされたことを確認します。</entry>
     </row>
     <row>
      <entry>w=majority</entry>
      <entry>過半数で確認する</entry>
      <entry>レプリカセットの過半数 (プライマリを含む) に書き込まれたことを確認します。この文字列は予約語になっています。</entry>
     </row>
     <row>
      <entry>w=&lt;tag set&gt;</entry>
      <entry>レプリカセットのタグセットで確認する</entry>
      <entry>タグセットで指定されたメンバーに書き込まれたことを確認します。</entry>
     </row>
     <row>
      <entry>j=true</entry>
      <entry>ジャーナルする</entry>
      <entry>プライマリに書き込まれ、そしてその記録がディスクに書き出されたことを確認します。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 
 <simplesect xml:id="mongo.writeconcerns.setting">
  <title>書き込み確認の使いかた</title>
  <para>
   書き込みを行うメソッド
   (<methodname>MongoCollection::insert</methodname>、
   <methodname>MongoCollection::update</methodname>、
   <methodname>MongoCollection::remove</methodname> そして
   <methodname>MongoCollection::batchInsert</methodname>)
   はどれも、オプションの引数で MongoDB サーバーに送るオプションを設定できます。
   このオプション配列を使って、次の例のように書き込み確認を指定できます。
  </para>
  <example>
   <title>書き込み操作での書き込み確認の指定</title>
   <programlisting role="php">
<![CDATA[
<?php
// w=0 を登録用に設定します
$collection->insert($someDoc, array("w" => 0));

// w=majority を更新用に設定します
$collection->update($someDoc, $someUpdates, array("w" => "majority"));

// w=5 と j=true を削除用に設定します
$collection->update($someDoc, array("w" => 5, "j" => true));

// w="AllDCs" を一括登録用に設定します
$collection->update(array($someDoc1, $someDoc2), array("w" => "AllDCs"));
?>
]]>
   </programlisting>
  </example>
  <para>
   書き込み確認を操作ごとに option 引数で設定するだけでなく、
   デフォルトの書き込み確認方法を設定することもできます。
  </para>
  <para>
   最初の方法は、<link
   linkend="mongo.mongoclient.construct.parameters">接続文字列</link>
   を使うものです。接続文字列には
   <literal>journal</literal> や <literal>w</literal> そして
   <literal>wTimeoutMS</literal> というオプションを指定できます。
  </para>
  <example>
   <title>接続文字列での書き込み確認の指定</title>
   <programlisting role="php">
<![CDATA[
<?php
$m = new MongoClient("mongodb://localhost/?journal=true&w=majority&wTimeoutMS=20000");
?>
]]>
   </programlisting>
  </example>

  <para>
   ドライバのバージョン 1.5 以降では、
   <methodname>MongoDB::setWriteConcern</methodname> や
   <methodname>MongoCollection::setWriteConcern</methodname>
   を呼んでデフォルトの書き込み確認方法を設定できるようになりました。その
   <classname>MongoDB</classname> や <classname>MongoCollection</classname>
   から作るすべての操作のデフォルトを設定できます。
  </para>
  <example>
   <title>MongoDB::setWriteConcern および MongoCollection::setWriteConcern</title>
   <programlisting role="php">
<![CDATA[
<?php
$m = new MongoClient("mongodb://localhost/");
$d = $m->demoDb;
$c = $d->demoCollection;

// データベースオブジェクトで w=3 として、タイムアウトを 25000ms にします
$d->setWriteConcern(3, 25000);

// コレクションオブジェクトで w=majority として、タイムアウトは変更しません
$c->setWriteConcern("majority");
?>
]]>
   </programlisting>
  </example>
 </simplesect>

 <simplesect xml:id="mongo.writeconcerns.unacknowledged">
  <title>確認なしの書き込み</title>
  <para>
   サーバー側で書き込み確認をしないようにすると、書き込み操作が極めて高速になります。
   ただし、書き込みが本当に成功したのかどうかは確認できません。
   いろんな理由で書き込みが失敗する可能性があります。
   ネットワーク障害、データベースサーバーがダウンしている、
   書き込み操作自体が無効 (system コレクションに書き込もうとしたり、
   キーの重複エラーになったり) などが考えられます。
  </para>
  <para>
   開発時には常に、確認付き書き込みを使うべきです
   (構文エラーや不正な操作、キーの重複などのうっかりミスを防ぐためです)。
   実運用のときには、「あまり重要ではない」データについては確認なしで書き込んでもいいでしょう。
   何が重要で何が重要でないかはアプリケーションによって異なりますが、一般的に
   「重要でない」とみなされるのは、ユーザーが生成したのではない自動生成されるデータ
   (クリックトラッキング情報や GPS の位置情報など) です。
   これらは秒間何千件ものレコードを受け取ることになります。
  </para>
  <para>
   一連の確認なし書き込みの最期は、必ず確認付き書き込みで終えることを強く推奨します。
   そのせいでパフォーマンスが大きく落ちることはないし、
   何かエラーがあればそれを捕捉できるようになります。
  </para>
  <example xml:id="mongo.writeconcerns.unacknowledged-example">
   <title>確認なしの書き込みの後に確認付き書き込みを続ける例</title>
   <programlisting role="php">
<![CDATA[
<?php
$collection->insert($someDoc, array("w" => 0));
$collection->update($criteria, $newObj, array("w" => 0));
$collection->insert($somethingElse, array("w" => 0));
try {
    $collection->remove($something, array("w" => 1));
} catch(MongoCursorException $e) {
    /* 例外処理 */
    /* ここでは、find() クエリを使って
    $somethingElse や $someDoc で生成された ID を調べ、
    実際にデータベースに書き込まれているかどうかを確認しないといけません。
    これで、一連の処理でいったい何が起こったのかがわかります。 */
}
?>
]]>
   </programlisting>
   <para>
    最後の書き込みで例外が発生すれば、データベースに何か問題が発生したことがわかります。
   </para>
  </example>
 </simplesect>

 <simplesect xml:id="mongo.writeconcerns.acknowledged">
  <title>確認付き書き込み</title>
  <para>
   この書き込みの場合、データベースが書き込み操作を受け付けたことを確認するまでは、
   書き込みが成功したとはみなしません。書き込みが失敗した場合は
   <classname>MongoCursorException</classname> をスローして失敗の内容を説明します。
   <classname>MongoClient</classname> のデフォルト設定は、確認付き書き込み (w=1) です。
  </para>
  <para>
   レプリカセットの中で何台のメンバーに書き込み終える (レプリケートされる)
   まで書き込み完了とみなさないかを指定することもできます。
   <example xml:id="mongo.writeconcerns.acknowledged-example">
    <title>確認付き書き込み</title>
    <programlisting role="php">
<![CDATA[
<?php
// プライマリに書き込まれたかどうかだけを確認します
$collection->insert($doc, array("w" => 1));

// プライマリの他に、レプリカセットのどれか一つのメンバーに書き込まれたことを確認します
$collection->insert($doc, array("w" => 2));

// プライマリの他に、レプリカセットのどれか六つのメンバーに書き込まれたことを確認します
// (まさかこんな設定をすることはないでしょう)
$collection->insert($doc, array("w" => 7));
]]>
    </programlisting>
    <para>
     確認付き書き込みの設定には十分注意しましょう。もしレプリカセットのメンバー数が
     5 の場合に確認付き書き込みの値を <literal>4</literal>
     にすると、レプリカセットのどれか一つのメンバーがメンテナンス中だったり
     一時的にネットワーク障害が発生した場合などに、書き込み操作がブロックされてしまいます。
    </para>
   </example>
  </para>
  <warning>
   <para>
    確認付き書き込みの設定に文字列を渡すと、特別な意味になります
    (レプリカセットのタグセットとして扱います)。数字を指定するつもりで文字列を使ってしまう
    (<literal>array("w" => "1")</literal> など)
    ことが <emphasis>ない</emphasis> ように気をつけましょう。これはタグセット名として扱われてしまいます。
   </para>
  </warning>
 </simplesect>

 <simplesect xml:id="mongo.writeconcerns.majority.acknowledged">
  <title>過半数の書き込み確認</title>
  <para>
   書き込み確認オプションとして、特別な文字列 <literal>majority</literal>
   を指定することができます。これは書き込み用におすすめの設定で、
   大災害に巻き込まれないようにするために必須です。
   この設定にすると、レプリカセットの過半数に書き込みが行き渡るまで成功したとみなさないので、
   ありがちなあらゆる障害に対応できるようになります。
  </para>
  <example xml:id="mongo.writeconcerns.majority.acknowledged-example">
   <title>過半数の確認付き書き込み</title>
   <programlisting role="php">
<![CDATA[
<?php
$collection->insert($someDoc, array("w" => "majority"));
?>
]]>
   </programlisting>
  </example>
 </simplesect>

 <!-- FIXME
 <simplesect xml:id="mongo.writeconcerns.tagset">
  <title>ReplicaSet TagSet Acknowledged</title>
 </simplesect>
 -->

 <simplesect xml:id="mongo.writeconcerns.journal">
  <title>ジャーナル書き込み</title>
  <para>
   レプリカセットへの接続時のデフォルトの書き込み確認は、
   プライマリへの書き込みさえできていればよいというものです。
   しかし、プライマリへの書き込みがディスクに反映されるまでには、
   数百ミリ秒単位の遅延があります。
   書き込みがディスクに記録されるまで成功とみなさないようにするには、
   <literal>j</literal> オプションを指定します。
   <example xml:id="mongo.writeconcerns.journalled">
    <title>確認付きジャーナル書き込み</title>
    <para>ジャーナルのフラッシュを強制します。</para>
    <programlisting role="php">
<![CDATA[
<?php
$options = array(
    "w" => 1,
    "j" => true,
);
try {
    $collection->insert($document, $options);
} catch(MongoCursorException $e) {
    /* 例外処理 */
}
]]>
    </programlisting>
   </example>
  </para>
 </simplesect>

 <simplesect role="seealso">
  &reftitle.seealso;
  <simplelist>
   <member>
    <link xlink:href="&url.mongodb.docs;applications/replication/#replica-set-write-concern">MongoDB の WriteConcern に関するドキュメント</link>
   </member>
  </simplelist>
 </simplesect>

 <simplesect role="changelog">
  &reftitle.changelog;
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>&Version;</entry>
      <entry>&Description;</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>1.3.0</entry>
      <entry>
       <classname>MongoClient</classname> が導入され、デフォルトで
       <link linkend="mongo.writeconcerns.acknowledged">確認付き</link>
       書き込みをするようになりました。デフォルトで確認なしの書き込みをする
       <classname>Mongo</classname> は非推奨となりました。
       writes.
      </entry>
     </row>
     <row>
      <entry>1.3.0</entry>
      <entry>
       書き込みオプション <literal>"safe"</literal> が非推奨になりました。
       新しい <classname>MongoClient</classname> クラスでは使えません。
       かわりに <literal>"w"</literal> オプションを使います。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </simplesect>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

