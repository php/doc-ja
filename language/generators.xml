<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: d096079ebb3e48ffbf2e211e3258a831dd7e9296 Maintainer: takagi Status: working -->
<chapter xml:id="language.generators" xmlns="http://docbook.org/ns/docbook">
 <title>ジェネレータ</title>

 <sect1 xml:id="language.generators.overview">
  <title>ジェネレータとは</title>
  <?phpdoc print-version-for="generators"?>

  <para>
   ジェネレータを使えば、シンプルな
   <link linkend="language.oop5.iterations">イテレータ</link>を簡単に実装できます。
   <classname>Iterator</classname> インターフェイスを実装したクラスを用意する
   オーバーヘッドや複雑さを心配する必要はありません。
  </para>

  <para>
   ジェネレータを使うと、&foreach; でデータ群を順に処理するコードを書くときに
   メモリ内で配列を組み立てなくても済むようになります。
   メモリ内で配列を組み立てると memory_limit を越えてしまうかもしれないし、
   無視できないほどの時間がかかってしまうかもしれません。
   配列を作る代わりに、ジェネレータ関数を書くことになります。これは通常の
   <link linkend="functions.user-defined">関数</link>と同じものですが、
   ジェネレータ関数は一度だけ
   <link linkend="functions.returning-values">return</link>
   するのではなく、必要に応じて何度でも &yield; することができます。
   つまり、値を繰り返し返せるということです。
  </para>

  <para>
   シンプルな例として、<function>range</function> 関数をジェネレータで実装しなおしてみましょう。
   標準の <function>range</function> 関数は、すべての値を含む配列を作ってそれを返します。
   結果的に、かなり大きな配列になる可能性があります。たとえば
   <command>range(0, 1000000)</command> を実行すると、
   100 MB を超えるメモリを使うことになります。
  </para>

  <para>
   その代替として、ジェネレータ <literal>xrange()</literal> を実装します。
   必要なメモリは、<classname>Iterator</classname>
   オブジェクトを作ってジェネレータの内部の状態を記録しておくのに必要なものだけになります。
   1 KB 未満で収まるでしょう。
  </para>

  <example>
   <title>ジェネレータを使った <function>range</function> の実装</title>
   <programlisting role="php">
<![CDATA[
<?php
function xrange($start, $limit, $step = 1) {
    if ($start < $limit) {
        if ($step <= 0) {
            throw new LogicException('Step must be +ve');
        }

        for ($i = $start; $i <= $limit; $i += $step) {
            yield $i;
        }
    } else {
        if ($step >= 0) {
            throw new LogicException('Step must be -ve');
        }

        for ($i = $start; $i >= $limit; $i += $step) {
            yield $i;
        }
    }
}

/* 次の例で、range() と xrange() が同じ結果を返すことに注目しましょう */

echo 'Single digit odd numbers from range():  ';
foreach (range(1, 9, 2) as $number) {
    echo "$number ";
}
echo "\n";

echo 'Single digit odd numbers from xrange(): ';
foreach (xrange(1, 9, 2) as $number) {
    echo "$number ";
}
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Single digit odd numbers from range():  1 3 5 7 9 
Single digit odd numbers from xrange(): 1 3 5 7 9 
]]>
   </screen>
  </example>
 </sect1>

 <sect1 xml:id="language.generators.syntax">
  <title>ジェネレータの構文</title>

  <para>
   ジェネレータ関数の見た目はふつうの関数とほぼ同じです。違うのは、値を返すのではなく、
   必要なだけ値を &yield; することです。
  </para>

  <para>
   ジェネレータ関数が呼ばれると、反復処理が可能なオブジェクトを返します。
   このオブジェクトを (&foreach; ループなどで) 反復させると、
   値が必要になるたびに PHP がジェネレータ関数を呼びます。
   そして、ジェネレータが値を yield した時点の状態を保存しておき、
   次に値が必要になったときにはそこから再開できるようにします。
  </para>

  <para>
   yield できる値がなくなると、ジェネレータ関数は何もせず単純に終了します。
   呼び出し元のコードでは、配列の要素をすべて処理し終えた後のように、そのまま処理が続きます。
  </para>

  <note>
   <para>
    ジェネレータは値を返すことができません。値を返そうとすると、コンパイルエラーになります。
    ジェネレータの中で空の <command>return</command> 文を書いても文法上は問題ありませんが、
    書いても無意味で、何も起こりません。
   </para>
  </note>

  <sect2 xml:id="language.generators.syntax.yield">
   <title><command>yield</command> キーワード</title>

   <para>
    ジェネレータ関数の肝となるのが <command>yield</command> キーワードです。
    最もシンプルな書きかたをすると、yield 文の見た目は return 文とほぼ同じになります。
    ただ、return の場合はそこで関数の実行を終了して値を返すのに対して、
    yield の場合はジェネレータを呼び出しているループに値を戻して
    ジェネレータ関数の実行を一時停止します。
   </para>

   <example>
    <title>値を yield する単純な例</title>
    <programlisting role="php">
<![CDATA[
<?php
function gen_one_to_three() {
    for ($i = 1; $i <= 3; $i++) {
        // yield を繰り返す間、$i の値が維持されることに注目しましょう
        yield $i;
    }
}

$generator = gen_one_to_three();
foreach ($generator as $value) {
    echo "$value\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
1
2
3
]]>
    </screen>
   </example>

   <note>
    <para>
     内部的には整数の連番のキーが yield する値とペアになり、
     配列と同じようになります。
    </para>
   </note>

   <caution>
    <para>
     yield を式のコンテキスト (代入文の右辺など)
     で使うときは、yield 文を括弧で囲む必要があります。
     たとえば次のようになります。
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
      $data = (yield $value);
]]>
     </programlisting>
    </informalexample>

    <para>
     次のように書くと、パースエラーになります。
    </para>

    <informalexample>
     <programlisting role="php">
<![CDATA[
      $data = yield $value;
]]>
     </programlisting>
    </informalexample>

    <para>
     この構文は、Generator オブジェクトの
     <link linkend="language.generators.object.send">send()</link>
     メソッドと組み合わせて使えます。
    </para>
   </caution>

   <sect3 xml:id="language.generators.syntax.yield.associative">
    <title>Yielding values with keys</title>

    <para>
     PHP also supports associative arrays, and generators are no different. In
     addition to yielding simple values, as shown above, you can also yield a
     key at the same time.
    </para>

    <para>
     The syntax for yielding a key/value pair is very similar to that used to
     define an associative array, as shown below.
    </para>

    <example>
     <title>Yielding a key/value pair</title>
     <programlisting role="php">
<![CDATA[
<?php
/* The input is semi-colon separated fields, with the first
 * field being an ID to use as a key. */

$input = <<<'EOF'
1;PHP;Likes dollar signs
2;Python;Likes whitespace
3;Ruby;Likes blocks
EOF;

function input_parser($input) {
    foreach (explode("\n", $input) as $line) {
        $fields = explode(';', $line);
        $id = array_shift($fields);

        yield $id => $fields;
    }
}

foreach (input_parser($input) as $id => $fields) {
    echo "$id:\n";
    echo "    $fields[0]\n";
    echo "    $fields[1]\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1:
    PHP
    Likes dollar signs
2:
    Python
    Likes whitespace
3:
    Ruby
    Likes blocks
]]>
     </screen>
    </example>

    <caution>
     <para>
      As with the simple value yields shown earlier, yielding a key/value pair
      in an expression context requires the yield statement to be
      parenthesised:
     </para>

     <informalexample>
      <programlisting role="php">
<![CDATA[
      $data = (yield $key => $value);
]]>
      </programlisting>
     </informalexample>
    </caution>
   </sect3>

   <sect3 xml:id="language.generators.syntax.yield.null">
    <title>Yielding null values</title>

    <para>
     Yield can be called without an argument to yield a &null; value with an
     automatic key.
    </para>

    <example>
     <title>Yielding &null;s</title>
     <programlisting role="php">
<![CDATA[
<?php
function gen_three_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(gen_three_nulls()));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
array(3) {
  [0]=>
  NULL
  [1]=>
  NULL
  [2]=>
  NULL
}
]]>
     </screen>
    </example>
   </sect3>

   <sect3 xml:id="language.generators.syntax.yield.references">
    <title>Yielding by reference</title>

    <para>
     Generator functions are able to yield values by reference as well as by
     value. This is done in the same way as
     <link linkend="functions.returning-values">returning references from functions</link>: 
     by prepending an ampersand to the function name.
    </para>

    <example>
     <title>Yielding values by reference</title>
     <programlisting role="php">
<![CDATA[
<?php
function &gen_reference() {
    $value = 3;

    while ($value > 0) {
        yield $value;
    }
}

/* Note that we can change $number within the loop, and
 * because the generator is yielding references, $value
 * within gen_reference() changes. */
foreach (gen_reference() as &$number) {
    echo (--$number).'... ';
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
2... 1... 0... 
]]>
     </screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 xml:id="language.generators.object">
  <title><classname>Generator</classname> オブジェクト</title>

  <para>
   When a generator function is called for the first time, an object of the
   internal <classname>Generator</classname> class is returned. This object
   implements the <classname>Iterator</classname> interface in much the same
   way as a forward-only iterator object would.
  </para>

  <para>
   Most methods in the <classname>Generator</classname> class have the same
   semantics as the methods in the <classname>Iterator</classname> interface,
   but generator objects also have one additional method:
   <command>send()</command>.
  </para>

  <caution>
   <para>
    <classname>Generator</classname> objects cannot be instantiated via
    <link linkend="language.oop5.basic.new">new</link>.
   </para>
  </caution>

  <!-- TODO: I've nicked this from the exception documentation, but I don't
             actually like it very much. At some point, let's try to break
             this and Exception out into proper class/method documentation.
   -->

  <example>
   <title>The <classname>Generator</classname> class</title>
   <programlisting role="php">
<![CDATA[
<?php
class Generator implements Iterator {
    public function rewind();          // Rewinds the iterator. If
                                       // iteration has already begun,
                                       // this will throw an exception.

    public function valid();           // Returns false if the
                                       // iterator has been closed.
                                       // Otherwise returns true.

    public function current();         // Returns the yielded value.

    public function key();             // Returns the yielded key.

    public function next();            // Resumes execution of the
                                       // generator.
    
    public function send($value);      // Sends the given value to the
                                       // generator as the result of
                                       // the yield expression and
                                       // resumes execution of the
                                       // generator.
}
]]>
   </programlisting>
  </example>

  <sect2 xml:id="language.generators.object.send">
   <title><methodname>Generator::send</methodname></title>

   <para>
    <methodname>Generator::send</methodname> allows values to be injected into
    generator functions while iterating over them. The injected value will be
    returned from the &yield; statement and can then be used like any other
    variable within the generator function.
   </para>

   <example>
    <title>Using <methodname>Generator::send</methodname> to inject values</title>
    <programlisting role="php">
<![CDATA[
<?php
function printer() {
    while (true) {
        $string = yield;
        echo $string;
    }
}

$printer = printer();
$printer->send('Hello world!');
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Hello world!
]]>
    </screen>
   </example>
  </sect2>
 </sect1>

 <sect1 xml:id="language.generators.comparison">
  <title>ジェネレータと <classname>Iterator</classname> オブジェクトとの比較</title>

  <para>
   ジェネレータの最大のメリットは、シンプルに書けることです。
   <classname>Iterator</classname> を実装するのに比べて、必要な決まり文句の数がかなり少なくなります。
   また、ジェネレータを使ったコードのほうが、一般的に読みやすくなります。
   たとえば、次の関数とクラスを比べてみましょう。これらはどちらも同じ働きをするものです。
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function getLinesFromFile($fileName) {
    if (!$fileHandle = fopen($fileName, 'r')) {
        return;
    }
 
    while (false !== $line = fgets($fileHandle)) {
        yield $line;
    }
 
    fclose($fileHandle);
}

// これを、下のクラスと比べてみると……

class LineIterator implements Iterator {
    protected $fileHandle;
 
    protected $line;
    protected $i;
 
    public function __construct($fileName) {
        if (!$this->fileHandle = fopen($fileName, 'r')) {
            throw new RuntimeException('Couldn\'t open file "' . $fileName . '"');
        }
    }
 
    public function rewind() {
        fseek($this->fileHandle, 0);
        $this->line = fgets($this->fileHandle);
        $this->i = 0;
    }
 
    public function valid() {
        return false !== $this->line;
    }
 
    public function current() {
        return $this->line;
    }
 
    public function key() {
        return $this->i;
    }
 
    public function next() {
        if (false !== $this->line) {
            $this->line = fgets($this->fileHandle);
            $this->i++;
        }
    }
 
    public function __destruct() {
        fclose($this->fileHandle);
    }
}
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   しかし、柔軟性を実現するために犠牲にしていることもあります。
   ジェネレータは前方にしか進めないイテレータなので、いったん反復処理が始まれば巻き戻すことができません。
   これはつまり、同じジェネレータを何度も使い回せないということです。
   ジェネレータ関数を呼んでもう一度作り直すか、
   <link linkend="language.oop5.cloning">clone</link> でクローンしないといけません。
  </para>
 </sect1>
</chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
