<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.15 $ -->
<!-- EN-Revision: 1.45 Maintainer: hirokawa Status: ready -->
<!-- CREDITS: takagi -->
 <chapter id="language.references">
  <title>リファレンスの説明</title>
  
  <sect1 id="language.references.whatare">
   <title>リファレンスとは?</title>
   <simpara>
    PHP において、リファレンスとは同じ変数の内容を異なった名前で
    コールすることを意味します。これは C のポインタのようなものではなく、
    シンボルテーブルのエイリアスです。PHP では、変数名と変数の内容は異なっており、
    このため、同じ内容は異なった複数の名前を有する事が可能であることに
    注意してください。最も良く似ているのは、Unix のファイル名とファイルの
    関係です。この場合、変数名はディレクトリエントリ、変数の内容は
    ファイル自体に対応します。リファレンスは、Unix ファイルシステムの
    ハードリンクのようなものであると考えられます。
   </simpara>
  </sect1>
  
  <sect1 id="language.references.whatdo">
   <title>リファレンスが行うことは何ですか?</title>
   <para>
    PHP のリファレンスにより二つの変数が同じ内容を参照することが可能です。
    つまり、以下のようなものを実行した場合です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a =& $b;
?>
]]>
     </programlisting>
    </informalexample>
    この場合、<varname>$a</varname> と <varname>$b</varname> は同じ内容を
    指します。
    <note>
     <para>
      ここで、<varname>$a</varname> と <varname>$b</varname> は完全に同じ
      で、<varname>$a</varname> が <varname>$b</varname> を指しているわけ
      ではなく、その逆でもありません。<varname>$a</varname> と
      <varname>$b</varname> は同じ場所を指しているのです。
     </para>
    </note>
   </para>
   <note>
    <para>
     リファレンスを含む配列をコピーする際に、そのリファレンスが解消される
     ことはありません。配列を関数に値渡しする場合も同様です。
    </para>
   </note>
   <para>
    リファレンスを返す関数や <literal>new</literal> 演算子でも
    同じ構文が使用可能です（PHP 4.0.4 以降）。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar =& new fooclass();
$foo =& find_var($bar);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
    <note>
     <para>
     <literal>&amp;</literal> 演算子を使用しない場合は、オブジェクトのコピーが
     作成されます。クラスの内部で <literal>$this</literal> を使用した場合、
     それはクラスの現在のインスタンスに対する操作を表します。
     <literal>&amp;</literal> のない代入はインスタンス（オブジェクト）のコピーを
     行い、<literal>$this</literal> はそのコピーに対する操作を表します。
     これはお望みの動作と異なるかもしれません。パフォーマンスやメモリ使用量の
     観点から、常に単一のインスタンスに対して操作を行いたくなることもあるでしょう。
     </para>
     <para>
      コンストラクタ内で <literal>@new</literal> のようにして
      <literal>@</literal> 演算子を使用すると、あらゆるエラーの表示を
      <emphasis>見えなくする</emphasis>ことが可能ですが、
      <literal>&amp;new</literal> を使用する場合にはこの機能は動作しません。
      Zend Engine の仕様により、これはパースエラーとなります。
     </para>
   </note>
   <warning>
    <para>
     関数の内部で <literal>global</literal> 宣言された変数にリファレンスを
     代入すると、そのリファレンスは関数の内部でのみ参照可能となります。
     これを避けるには、<varname>$GLOBALS</varname> 配列を使用します。
     <example>
      <title>関数内でのグローバル変数の参照</title>
      <programlisting role="php">
<![CDATA[
<?php
$var1 = "Example variable";
$var2 = "";

function global_references($use_globals)
{
    global $var1, $var2;
    if (!$use_globals) {
        $var2 =& $var1; // 関数の内部でのみ参照可能
    } else {
        $GLOBALS["var2"] =& $var1; // 関数の外部でも参照可能
    }
}

global_references(false);
echo "var2 の値は '$var2'\n"; // var2 の値は ''
global_references(true);
echo "var2 の値は '$var2'\n"; // var2 の値は 'Example variable'
?>
]]>
      </programlisting>
     </example>
     <literal>global $var;</literal> は、<literal>$var
     =&amp; $GLOBALS['var'];</literal> の短縮版だと考えてください。
     これにより、他のリファレンスを <literal>$var</literal> に代入し、
     ローカル変数のリファレンスのみを変更します。
    </para>
   </warning>
   <note>
    <para>
     <link
     linkend="control-structures.foreach">foreach</link> ステートメント
     の内部でリファレンス変数に値を代入すると、リファレンスも変更されます。
     <example>
      <title>リファレンスと foreach ステートメント</title>
      <programlisting role="php">
<![CDATA[
<?php
$ref = 0;
$row =& $ref;
foreach (array(1, 2, 3) as $row) {
    // 何かを実行します
}
echo $ref; // 3 - 配列の最後の要素
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
   <warning>
    <para>
     複雑な配列では、リファレンスではなく単にコピーされてしまうこともあります。
     そのため、以下のような例は期待通りに動作しません。
     <example>
      <title>リファレンスと複雑な配列</title>
      <programlisting role="php">
<![CDATA[
<?php
$top = array(
    'A' => array(),
    'B' => array(
        'B_b' => array(),
    ),
);

$top['A']['parent'] = &$top;
$top['B']['parent'] = &$top;
$top['B']['B_b']['data'] = 'test';
print_r($top['A']['parent']['B']['B_b']); // array()
?>
]]>
      </programlisting>
     </example>
    </para>
   </warning>
   <para>
    リファレンスの第 2 の使用法は、変数のリファレンス渡しです。この場合、
    関数でローカル変数が作成され、コール側の変数が、それと同じ内容への
    リファレンスとなります。例を示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var) 
{
  $var++;
}

$a=5;
foo($a);
?>
]]>
     </programlisting>
    </informalexample>
    この結果、<varname>$a</varname> は 6 となります。これは、関数
    <varname>foo</varname> の中では、変数 <varname>$var</varname> は
    <varname>$a</varname> と同じ内容を指しているためです。
    より詳細な説明は、
    <link linkend="language.references.pass">リファレンス渡し</link>
    を参照ください。
   </para>
   <simpara>
    リファレンスの第 3 の使用法は、
    <link linkend="language.references.return">リファレンスによる返り値
    </link>です。
   </simpara>
  </sect1>
  
  <sect1 id="language.references.arent">
   <title>リファレンスが行わないこと</title>
   <para>
    これまでに説明したように、リファレンスはポインタではありません。このため、
    次の例は期待通りに動作しません。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var)
{
    $var =& $GLOBALS["baz"];
}
foo($bar); 
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    ここでの動作としては、関数 <varname>foo</varname> の
    <varname>$var</varname> はコール側の <varname>$bar</varname>
    と関連付けられますが、<varname>$GLOBALS["baz"]</varname>
    に再結合されるといったものになります。<varname>$bar</varname>
    は関数 <varname>foo</varname> で利用できないため、
    リファレンス以外にはコール側の変数スコープにある
    <varname>$bar</varname> を何かに結合する手段はありません
    （この変数は <varname>$var</varname> として表されていますが、
    <varname>$var</varname> はその変数の内容のみを有しており、
    コール側のシンボルテーブルで名前と変数を結合したものではありません）。
    関数内で指定した変数を参照するには、<link 
    linkend="language.references.return">リファレンス返し</link>
    が使用可能です。
   </simpara>
  </sect1>
  
  <sect1 id="language.references.pass">
   <title>リファレンス渡し</title>
   <para>
    リファレンスにより関数に変数を渡すことが可能です。この場合、関数内で
    その引数を修正可能になります。構文は次のようになります。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo(&$var)
{
    $var++;
}

$a=5;
foo($a);
// $a はここでは 6 です
?>
]]>
     </programlisting>
    </informalexample>
    関数コールの際には、リファレンス記号がないことに注意してください。
    関数定義にのみリファレンス記号があります。リファレンスで正しく引数を
    渡すには、関数定義のみで十分です。以前のバージョンの PHP では
    <literal>foo(&amp;$a);</literal> のような形式で &amp; を利用すると
    "Call-time pass-by-reference" という警告が発生していましたが、
    これは今では廃止されています。
  </para>
  <para>
    次のものはリファレンスで渡すことが可能です。
    <itemizedlist>
     <listitem>
      <simpara>
       変数、すなわち、<literal>foo($a)</literal>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       new 命令、すなわち、<literal>foo(new foobar())</literal>
      </simpara>
     </listitem>
     <listitem>
      <para>
       関数から返されるリファレンスは、次のようになります。
       <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &bar()
{
    $a = 5;
    return $a;
}
foo(bar());
?>
]]>
    </programlisting>
       </informalexample>
       <link linkend="language.references.return">リファレンスによる
       返り値</link> に関する説明も参照ください。
      </para>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    他の式は、結果が未定義となるため、リファレンスで渡すべきではありません。
    例えば、リファレンスで渡す次の例は、無効です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function bar() // & がないことに注意
{
    $a = 5;
    return $a;
}
foo(bar()); // PHP 5.0.5 以降、致命的なエラーが発生する

foo($a = 5); // 式、変数ではない
foo(5); // 致命的なエラーが発生する
?>
]]>
     </programlisting>
    </informalexample>
    以上の説明は、PHP 4.0.4 以降用です。
   </para>
  </sect1>

  <sect1 id="language.references.return">
   <title>リファレンスを返す</title>
   <para>
    リファレンスを返すことは、結合する変数を見付けるために関数を使用し
    たい場合に便利です。パフォーマンスを向上させるためだけの目的で
    この機能を用いることは<emphasis>やめてください</emphasis>。
    そのようなことをしなくても、PHP エンジンが自動的に最適化を行います。
    リファレンスを返すのは、そうすべき妥当な理由がある場合に限られます!
    リファレンスを返す場合、次の構文を使用して下さい。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function &find_var($param)
{
    /* ...コード... */
    return $found_var;
}

$foo =& find_var($bar);
$foo->x = 2;
?>
]]>
     </programlisting>
    </informalexample>
    この例では、関数 <varname>find_var</varname> により返された
    オブジェクトのプロパティが、設定されます。リファレンス構文を
    使用しない場合のようにコピーとなるわけではありません。
   </para>
   <note>
    <simpara>
     パラメータを渡す場合と異なり、ここでは、通常のようにコピーでは
     なくリファレンスで返り値を指定し、リファレンス結合を指定するために
     両方の場所で <literal>&amp;</literal> を使用する必要があります。
     <varname>$foo</varname> について行われたのは、通常の代入では
     ありません。
    </simpara>
   </note>
   <note>
    <simpara>
     以下のような形式で関数からリファレンスを返そうとした場合、
     <literal>return ($found_var);</literal> これは、あなたが望んでいるように
     <emphasis>式</emphasis> の結果を返してくれることは<emphasis>ありません</emphasis>。
     可能なことは、値へのリファレンスを返すことができるということだけで、
     それ以外の何者でもありません。
     PHP 4.4.0 および PHP 5.1.0 以降では、式の結果や <literal>new</literal>
     演算子の結果をそのまま返そうとした場合に <constant>E_NOTICE</constant>
     エラーが発生します。
    </simpara>
   </note>
  </sect1>
  
  <sect1 id="language.references.unset">
  <title>リファレンスの解除</title>
   <para>
    リファレンスを解除することは、ちょうど変数名と変数の内容の結合を
    解除することに相当します。これは、変数の内容が破棄されることを
    意味しません。例えば、
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b =& $a;
unset($a);
?>
]]>
     </programlisting>
    </informalexample>
    は、<varname>$b</varname> を削除せず、<varname>$a</varname> のみを
    削除します。
   </para>
   <simpara>
    ここでも、Unix の <command>unlink</command> コールと類似したものと
    考えると便利です。
   </simpara>
  </sect1>
  
  <sect1 id="language.references.spot">
   <title>リファレンスの適用範囲</title>
   
   <simpara>
    PHP の多くの構文構造は、リファレンス機構を利用して実装されています。
    このため、前記のリファレンス結合に関する事項はこれらの構造についても
    適用されます。リファレンス渡しおよびリファレンスの返り値のような
    いくつかの構造について前節で記述されています。リファレンスを使用する
    他の構造には次のものがあります。
   </simpara>
   
   <sect2 id="references.global">
    <title><literal>global</literal>リファレンス</title>

    <para>
     変数を <command>global $var</command> として宣言した場合、実際には
     グローバル変数へのリファレンスを作成したことになります。この意味は、
     次の例と同じです。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var =& $GLOBALS["var"];
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     これは、例えば、<varname>$var</varname> を削除してもグローバル変数は
     削除されないことを意味します。
    </simpara>
   </sect2>
   
   <sect2 id="references.this">
    <title><literal>$this</literal></title>
    
    <simpara>
     オブジェクトのメソッドでは、<varname>$this</varname> は
     常にコール側のオブジェクトへのリファレンスです。
    </simpara>
   </sect2>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
