<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 2fd3f0c96d9d221fe37109775af4df4cf949d5d8 Maintainer: takagi Status: ready -->
 <sect1 xml:id="internals2.memory.management" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>基本的なメモリ管理</title>

  <para>
   C 言語でのプログラミングでは、開発者がメモリ管理を自分で行う必要があります。
   PHP はウェブサーバのモジュールとして使われることが多いので、
   メモリリークを引き起こさないようにメモリ管理が特に重要となります。
   さらに注意を要するのは、PHP がスレッド環境で使われる可能性があるということです。
   この場合、グローバル変数が競合状態になる可能性があります。
   スレッドグローバルなデータの扱いかたについての情報は、
   スレッドの分離機能を扱う <xref linkend="internals2.memory.TSRM"/>
   のドキュメントを参照ください。
  </para>

  <para>
   これらに加え、さらに Zend Engine 独特のパターンとして注意しなければならないのは、
   比較的短時間の間に zval 構造体やその他の小さなメモリブロックの確保と解放を
   頻繁に繰り返すということです。PHP のメモリ管理では、
   <link linkend="ini.memory-limit">memory_limit</link>
   にも注意を払わなければなりません。
  </para>

  <para>
   これらの要件を満たすために Zend Engine は、
   リクエスト単位のデータを処理するための特別なメモリマネージャを提供しています。
   リクエスト単位のデータとは、単一のリクエストを処理するためにのみ必要となるデータで
   リクエストが終了する時点で解放されるものです。
   拡張モジュールの作者は、通常は以下の表にあるルーチンを使うだけで済むことになります。
   これらは利便性を考慮してマクロとして実装されていますが、
   このドキュメントでは関数として扱います。
  </para>

  <table xml:id="internals2.memory.management.apis">
   <title>主要メモリ API 群</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>プロトタイプ</entry>
      <entry>説明</entry>
     </row>
    </thead>
    <tbody>
     
     <row>
      <entry><code>void *emalloc(size_t size)</code></entry>
      <entry><code>size</code> バイトのメモリを確保する。</entry>
     </row>

     <row>
      <entry><code>void *ecalloc(size_t nmemb, size_t size)</code></entry>
      <entry>
       <code>size</code> バイトのバッファを
       <code>nmemb</code> 件ぶん作成し、ゼロで初期化する。
      </entry>
     </row>

     <row>
      <entry><code>void *erealloc(void *ptr, size_t size)</code></entry>
      <entry>
       バッファ <code>ptr</code> のサイズを変更する。
       <code>emalloc</code> を用いて <code>size</code> バイトのメモリを確保する。
      </entry>
     </row>

     <row>
      <entry><code>void efree(void *ptr)</code></entry>
      <entry>
       <code>ptr</code> が指すバッファを解放する。
       解放するバッファは <code>emalloc</code> で確保したものでなければならない。
      </entry>
     </row>

     <row>
      <entry>
       <code>void *safe_emalloc(size_t nmemb, size_t size, size_t offset)</code>
      </entry>
      <entry>
       <code>size</code> バイトのブロックを <code>nmemb</code>
       個、そしてそれに加えて <code>offset</code> バイトを保持するバッファを確保する。
       <code>emalloc(nmemb * size + offset)</code> と似ているが、
       それに加えてオーバーフロー対策の特別なプロテクトが施される。
      </entry>
     </row>

     <row>
      <entry><code>char *estrdup(const char *s)</code></entry>
      <entry>
       NULL 終端の文字列 <code>s</code> を保持できる大きさのバッファを確保し、
       <code>s</code> をそのバッファにコピーする。
      </entry>
     </row>

     <row>
      <entry>
       <code>char *estrndup(const char *s, unsigned int length)</code>
      </entry>
      <entry>
       <code>estrdup</code> と似ているが、NULL 終端文字列の長さが事前にわかっている場合に使う。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <simpara>
    C 標準ライブラリの同等の関数群とは異なり、Zend Engine
    のメモリ管理関数はメモリの確保に失敗しても NULL を返しません。
    そのかわりに、処理を放棄して現在のリクエストを終了させます。
   </simpara>
  </note>

  <para>
   上でも説明したように、メモリをきちんと管理してメモリリークを防ぐことは非常に大切です。
   確保したメモリは、不要になったらすぐ解放するようにしましょう。
   安全策として、Zend Engine では、上の API 群で確保したメモリは
   リクエストの終了時にすべて解放するようになっています。
   <code>--enable-debug</code> オプションつきで PHP をビルドした場合は、
   これは警告を発生させます。
  </para>

  <example xml:id="internals2.memory.management.example.leak">
   <title>PHP のメモリリーク警告</title>
   <programlisting role="c">
<![CDATA[
ZEND_FUNCTION(leak)
{
    long leakbytes = 3;

    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|l", &leakbytes) == FAILURE) {
        return;
    }

    emalloc(leakbytes);
}
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
[Thu Oct 22 02:14:57 2009]  Script:  '-'
/home/johannes/src/PHP_5_3/Zend/zend_builtin_functions.c(1377) :  Freeing 0x088888D4 (3 bytes), script=-
=== Total 1 memory leaks detected ===
]]>
   </screen>
  </example>

  <note>
   <simpara>
    PHP の変数を扱う際には、変数用のメモリを emalloc
    で確保して参照カウンタに注意を払う必要があります。
    詳細は <xref linkend="internals2.variables"/> を参照ください。
   </simpara>
  </note>

  <note>
   <simpara>
    このリーク検出機能が働くのは、emalloc で確保したメモリブロックに対してのみです。
    より詳細な解析を行うには、valgrind や libumem
    といったメモリチェッカーを使うことをおすすめします。
    これらによる解析時には、PHP のメモリチェッカーを無効化することもできます。
    そのためには、環境変数 USE_ZEND_ALLOC=0
    を設定してから PHP を開始させます。
   </simpara>
  </note>

 </sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
