<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 04077dd209c5fb9de2b55fcaf57cd4beef8c4273 Maintainer: takagi Status: ready -->
<!-- CREDITS: hirokawa -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>演算子</title>
  <simpara>
   演算子とは、ひとつ以上の値 (あるいはプログラミング用語における「式」)
   から別の値 (制御構造が式になるように) を生み出すものです。
   つまり、値を返す関数や制御構造 (たとえば print) は演算子と考えられますし、
   何も値を返さないもの (たとえば echo) はそれ以外のものとなります。
  </simpara>
  <para>
   演算子には 3 種類あります。ひとつめは単項演算子で、これはひとつの値に
   対してのみ作用します。例えば ! (否定演算子) や ++ (加算子) などです。
   ふたつめは二項演算子と呼ばれるものです。PHP がサポートしている演算子の
   ほとんどはここに含まれ、その一覧は
   <link linkend="language.operators.precedence">演算子の優先順位</link>
   にあります。
  </para>
  <para>
   最後のグループは、三項演算子 ?: です。これは、2 つの文や実行経路から選択すると
   いうよりも、3 番目の式に応じて 2 つの式から選択するために使用されるべきです。
   この演算子を使用する式は、括弧で囲んでおくことをお勧めします。
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>演算子の優先順位</title>
   <para>
    演算子の優先順位は、二つの式が"緊密に"結合している度合いを指定します。
    例えば、式 <literal>1 + 5 * 3</literal> の答えは
    <literal>16</literal> になり、<literal>18</literal> とはなりません。
    これは乗算演算子("*")は、加算演算子("+")より高い優先順位を有するか
    らです。必要に応じて強制的に優先順位を設定するために括弧を使用する
    ことが可能です。例えば、<literal>18</literal>と評価するためには、
    <literal>(1 + 5) * 3</literal> とします。
    演算子の優先順位が等しい場合は、左から右へ順に評価されます。
   </para>
   <para>
    以下の表では、優先順位が高い順に演算子を挙げています。
    同じ行にある演算子は優先順位が等しくなります。そのような場合は、
    結合時の評価にしたがって評価順が決まります。
    <table>
     <title>演算子の優先順位</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>結合時の評価</entry>
        <entry>演算子</entry>
        <entry>追加情報</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>結合しない</entry>
        <entry>clone new</entry>
        <entry><link linkend="language.oop5.cloning">clone</link> および <link linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>[</entry>
        <entry><function>array</function></entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>++ --</entry>
        <entry>
         <link linkend="language.operators.increment">加算子/減算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>~ - (int) (float) (string) (array) (object) (bool) @</entry>
        <entry>
         <link linkend="language.types">型</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>instanceof</entry>
        <entry>
         <link linkend="language.types">型</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>!</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>* / %</entry>
        <entry>
         <link linkend="language.operators.arithmetic">代数演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>+ - .</entry>
        <entry>
         <link linkend="language.operators.arithmetic">代数演算子</link>&listendand; 
         <link linkend="language.operators.string">文字列演算子</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>&lt; &lt;= &gt; &gt;= &lt;&gt;</entry>
        <entry>
         <link linkend="language.operators.comparison">比較演算子</link>
        </entry>
       </row>
       <row>
        <entry>結合しない</entry>
        <entry>== != === !==</entry>
        <entry>
         <link linkend="language.operators.comparison">比較演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>&listendand; 
         <link linkend="language.references">リファレンス</link></entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>^</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>|</entry>
        <entry>
         <link linkend="language.operators.bitwise">ビット演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>&amp;&amp;</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>||</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>? :</entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">三項演算子</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </entry>
        <entry>
         <link linkend="language.operators.assignment">代入演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>and</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>xor</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>or</entry>
        <entry>
         <link linkend="language.operators.logical">論理演算子</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry>,</entry>
        <entry>さまざまな利用法</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    結合時の評価が left の場合は式が左から右に評価され、一方 right の場合は
    その逆となります。
    <example>
     <title>結合時の評価</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
    コードの可読性を高めるためには括弧を使用します。
   </para>
   <note>
    <para>
     <literal>=</literal> は他のほとんどの演算子よりも優先順位が低いはずなのにもかかわらず、
     PHP は依然として <literal>if (!$a = foo())</literal>
     のような式も許します。この場合は <literal>foo()</literal> の返り値が
     <varname>$a</varname> に代入されます。
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="language.operators.arithmetic">
   <title>代数演算子</title>
   <simpara>
    学校で習った基礎代数を憶えていますか?
    この演算子はそれらと同様に動作します。
   </simpara>
   <table>
    <title>代数演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>-$a</entry>
       <entry>負にする</entry>
       <entry><varname>$a</varname> の逆</entry>
      </row>
      <row>
       <entry>$a + $b</entry>
       <entry>加算</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> の合計</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>減算</entry>
       <entry><varname>$a</varname> と <varname>$b</varname> の差</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>乗算</entry>
        <entry><varname>$a</varname> および <varname>$b</varname> の積</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>除算</entry>
        <entry><varname>$a</varname> および <varname>$b</varname> の商</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>剰余</entry>
       <entry><varname>$a</varname> を <varname>$b</varname> で割った余り</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  
   <simpara>
    除算演算子 ("/") の返す値は浮動小数点数となります。
    ただし、ふたつのオペランドがともに整数 (あるいは整数に変換できる文字列)
    であり、かつ結果が割り切れる場合には整数値を返します。
   </simpara>
   <simpara>
    剰余演算子は、まず両方のオペランドを整数に直し
    (小数点以下を切り捨てます)
    てから処理を行います。
   </simpara>
   <note>
    <simpara>
     <literal>$a</literal> が負の場合、<literal>$a % $b</literal>
     は負の値となることを覚えておきましょう。
    </simpara>
   </note>
   <simpara>
    マニュアルの
    <link linkend="ref.math">数学関数</link>の項も参照してください。
   </simpara>

  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>代入演算子</title>
   <simpara>
    代入演算子の基本となるものは "=" です。この演算子に関して最初に
    思い付く意味は"等しい"であるかもしれません。しかし、そうではありません。
    本当は、左オペランドに右オペランドの式の値を設定する("得て代入する")
    ことを意味します。
   </simpara>
   <para>
    代入式の値は、代入される値です。つまり、"<literal>$a = 3</literal>" の値は、3 です。
    これにより、以下のようなトリッキーなことができるようになります。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a は 9 に等しく、$b は 4 にセットされます。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    基本代入演算子に加えて、全ての<link linkend="language.operators">
    バイナリ演算子</link>、配列結合および文字列演算子に関して
    「複合演算子」があります。
    これにより、式の中の値を使用し、その値をその式の結果とすることができます。
    例えば、
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // $a を 8 にセットします。$a = $a + 5; と同じです。
$b = "Hello ";
$b .= "There!"; // $bを"Hello There!"にセットします。$b = $b . "There!";と同じです。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    代入は、元の変数を新しい変数にコピーする(値による代入)ため、
    片方の変数に対する変更はもう片方に影響を与えないということに
    注意してください。この動作により、密なループの内側で大きな配列のようなものを
    コピーする必要がある場合には問題を生じる可能性があります。
    <computeroutput>$var = &amp;$othervar;</computeroutput>
    構文を用いた、参照による代入もサポートしています。
    '参照による代入'は、両方の変数が同じデータを指し、コピーを
    行わないことを意味します。参照に関する詳細については、
    <link linkend="language.references">リファレンスの説明</link>も
    参照ください。
    PHP 5 では、新しいキーワード
    <link linkend="language.oop5.cloning">clone</link>
    を使用して明示的に指定しない限り、オブジェクトは自動的に参照による代入になります。
   </para>
   </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>ビット演算子</title>
   <simpara>
    ビット演算子は、整数値の特定のビットの評価や操作を行います。
   </simpara>
   <table>
    <title>ビット演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>ビット積</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> の両方にセットされているビットがセットされます</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>ビット和</entry>
       <entry><varname>$a</varname> または <varname>$b</varname> のどちらかにセットされているビットがセットされます</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>排他的論理和</entry>
       <entry><varname>$a</varname> または <varname>$b</varname> のどちらか一方にセットされており、両方にセットされていないビットがセットされます</entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>否定</entry>
       <entry><varname>$a</varname> にセットされているビットはセットせず、そうでないものは逆にします</entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>左シフト</entry>
       <entry><varname>$a</varname> のビットを左に <varname>$b</varname> ビットシフトする (各シフトは "2をかける"
    ことを意味します)
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>右シフト</entry>
       <entry><varname>$a</varname> のビットを右に <varname>$b</varname> ビットシフトします (各シフトは "2で割る"
    ことを意味します)
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    PHP のシフト処理は算術シフトです。両端からあふれたビットは捨てられます。
    左シフトをすると右側にはゼロが埋められます。
    符号ビットは左端からあふれて消えます。
    つまり、オペランドの符号は維持されないということです。
    右シフトの際には、符号ビットと同じ内容が左端から埋められます。
    つまり、この場合はオペランドの符号が維持されます。
   </para>
   <para>
    括弧を使うことで、望みどおりの
    <link linkend="language.operators.precedence">優先順位</link>
    で処理させることができます。たとえば、<literal>$a &amp; $b == true</literal>
    はまず等価かどうかを評価してからビット演算を行いますが
    <literal>($a &amp; $b) == true</literal>
    はまずビット演算を行ってから等価かどうかを評価します。
   </para>
   <para>
    データ型の変換に注意しましょう。両辺のパラメータが文字列の場合、
    ビット演算子は文字の ASCII コードで演算を行います。
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
PHP の ini 設定 error_reporting はビット値を用いています。
これを用いて、特定のビットを落とす演算の例を見てみましょう。
notice 以外のすべてのエラーを表示させるには、
php.ini ファイルで
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
と指定することになります。
      </literallayout>
     </para>
     <para>
      <literallayout>
まずは E_ALL。
<computeroutput>00000000000000000111011111111111</computeroutput>
そして E_NOTICE...。
<computeroutput>00000000000000000000000000001000</computeroutput>
... これを <literal>~</literal> で逆転させます。
<computeroutput>11111111111111111111111111110111</computeroutput>
最後に AND (&amp;) を使い、両方ともビットが立っているところをみつけます。
<computeroutput>00000000000000000111011111110111</computeroutput>
      </literallayout>
     </para>
     <para>
      <literallayout>
同じ結果を得るもうひとつの方法として、 XOR (<literal>^</literal>)
を使ってどちらか一方だけ立っているビットを探すという方法もあります。
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting を使って、特定のビットを立てる処理の例を見てみましょう。
通常のエラーとリカバー可能なエラーだけを表示させるには、次のようにします。
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
この処理は、 E_ERROR
<computeroutput>00000000000000000000000000000001</computeroutput>
と
<computeroutput>00000000000000000001000000000000</computeroutput>
を OR (<literal>|</literal>) 演算子でつないで、
少なくともどちらかのビットが立っているところを取得します。
<computeroutput>00000000000000000001000000000001</computeroutput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>整数値におけるビット AND、OR および XOR 演算</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * このへんは無視してください。
 * たんに結果をきれいに表示させるためだけのものです。
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
EOH;


/*
 * ここからが本番
 */

$values = array(0, 1, 2, 4, 8);
$test = 1 + 4;

echo "\n Bitwise AND \n";
foreach ($values as $value) {
    $result = $value & $test;
    printf($format, $result, $value, '&', $test);
}

echo "\n Bitwise Inclusive OR \n";
foreach ($values as $value) {
    $result = $value | $test;
    printf($format, $result, $value, '|', $test);
}

echo "\n Bitwise Exclusive OR (XOR) \n";
foreach ($values as $value) {
    $result = $value ^ $test;
    printf($format, $result, $value, '^', $test);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>文字列でのビット XOR 演算</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // 出力は '5'

echo "12" ^ "9"; // 出力はバックスペース文字 (ascii 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

echo "hallo" ^ "hello"; // 出力は、ascii コード #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // 出力は 1
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // 出力は 1
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>整数値のビットシフト</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * これが例です
 */

echo "\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = 4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places);

$val = 4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = 4;
$places = 4;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond 0');


echo "\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val >> $places;
p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');

$val = -4;
$places = 2;
$res = $val >> $places;
p($res, $val, '>>', $places, 'bits shift out right side');

$val = -4;
$places = 3;
$res = $val >> $places;
p($res, $val, '>>', $places, 'same result as above; can not shift beyond -1');


echo "\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\n";

$val = 4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 4;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = 4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places, 'sign bits get shifted out');

$val = 4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side');


echo "\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\n";

$val = -4;
$places = 1;
$res = $val << $places;
p($res, $val, '<<', $places, 'zeros fill in right side');

$val = -4;
$places = (PHP_INT_SIZE * 8) - 3;
$res = $val << $places;
p($res, $val, '<<', $places);

$val = -4;
$places = (PHP_INT_SIZE * 8) - 2;
$res = $val << $places;
p($res, $val, '<<', $places, 'bits shift out left side, including sign bit');


/*
 * このへんは無視してください。
 * たんに結果をきれいに表示させるためだけのものです。
 */

function p($res, $val, $op, $places, $note = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("Expression: %d = %d %s %d\n", $res, $val, $op, $places);

    echo " Decimal:\n";
    printf("  val=%d\n", $val);
    printf("  res=%d\n", $res);

    echo " Binary:\n";
    printf('  val=' . $format, $val);
    printf('  res=' . $format, $res);

    if ($note) {
        echo " NOTE: $note\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 1073741824 = 4 << 28
 Decimal:
  val=4
  res=1073741824
 Binary:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000

Expression: -2147483648 = 4 << 29
 Decimal:
  val=4
  res=-2147483648
 Binary:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 30
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -2147483648 = -4 << 29
 Decimal:
  val=-4
  res=-2147483648
 Binary:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000

Expression: 0 = -4 << 30
 Decimal:
  val=-4
  res=0
 Binary:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 >> 1
 Decimal:
  val=4
  res=2
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side

Expression: 1 = 4 >> 2
 Decimal:
  val=4
  res=1
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001

Expression: 0 = 4 >> 3
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out right side

Expression: 0 = 4 >> 4
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0


--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 >> 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side

Expression: -1 = -4 >> 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: bits shift out right side

Expression: -1 = -4 >> 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1


--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 << 1
 Decimal:
  val=4
  res=8
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTE: zeros fill in right side

Expression: 4611686018427387904 = 4 << 60
 Decimal:
  val=4
  res=4611686018427387904
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000

Expression: -9223372036854775808 = 4 << 61
 Decimal:
  val=4
  res=-9223372036854775808
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTE: sign bits get shifted out

Expression: 0 = 4 << 62
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side


--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 << 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTE: zeros fill in right side

Expression: -9223372036854775808 = -4 << 61
 Decimal:
  val=-4
  res=-9223372036854775808
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000

Expression: 0 = -4 << 62
 Decimal:
  val=-4
  res=0
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit
]]>
     </screen>
    </example>
   </para>
   <warning>
    <para>
     32 ビットシステムでは 32 ビット以上の右シフトは行わないでください。
     また、結果が 32 ビットを超えてしまうような左シフトも行わないでください。
     PHP_INT_MAX を超える数のビット演算には、gmp 拡張モジュールの関数を使用します。
    </para>
   </warning>
   <para>
    <function>pack</function>,
    <function>unpack</function>,
    <function>gmp_and</function>,
    <function>gmp_or</function>,
    <function>gmp_xor</function>,
    <function>gmp_testbit</function>,
    <function>gmp_clrbit</function>
    も参照ください。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>比較演算子</title>
   <simpara>
    比較演算子は、その名前が示すように、二つの値を比較します。
   </simpara>
   <table>
    <title>比較演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>等しい</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> に等しい時に &true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>等しい</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> に等しく同じ型でである場合に &true; (PHP 4 で導入)。
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>等しくない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> に等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;> $b</entry>
       <entry>等しくない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> に等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>等しくない</entry>
       <entry>
        <varname>$a</varname> が <varname>$b</varname> と等しくないか、同じ型でない場合に &true; (PHP 4 で導入)。
       </entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>より少ない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> より少ない時に &true;。</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>より多い</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> より多い時に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>より少ないか等しい</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> より少ないか等しい時に &true;。</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>より多いか等しい</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> より多いか等しい時に &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    整数値を文字列と比較する際、文字列が
    <link linkend="language.types.string.conversion">数値に変換されます</link>。
    数値形式の文字列を比較する場合、それは整数として比較されます。これらの
    ルールは、
    <link linkend="control-structures.switch">switch</link> 文にも適用されます。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("1" == "1e0"); // 1 == 1 -> true

switch ("a") {
case 0:
    echo "0";
    break;
case "a": // "a" は 0 にマッチするので、決してここにはたどりつきません
    echo "a";
    break;
}
?>
]]>
     </programlisting>
    </informalexample> 
   </para>

   <para>
    多くの型では、以下の表に（上から順に）したがって比較が行われます。
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>さまざまな型の比較</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>第 1 オペランドの型</entry>
       <entry>第 2 オペランドの型</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> または <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>&null; を "" に変換し、数値または文字として比較します</entry>
      </row>
      <row>
       <entry><type>bool</type> または <type>null</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>bool</type> に変換し、&false; &lt; &true; と判断します</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>組み込みクラスには独自の比較基準が定義されています。それ以外の
        クラスは比較できません。同じクラスであるかどうかは - プロパティが
        同じ値であるかどうかを配列形式で比較（PHP 4）、PHP 5 では <link
        linkend="language.oop5.object-comparison">ここで説明されています</link>。
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type> または <type>number</type></entry>
       <entry><type>string</type>, <type>resource</type> または <type>number</type></entry>
       <entry>文字列やリソースを数値に変換し、算術演算を行います</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>要素数の少ない配列のほうが小さくなります。オペランド 1 のキーが
        オペランド 2 に存在しない場合、配列は比較できません。そうでない場合は
        個々の要素の値を比較します（以下の例を参照ください）</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>array</type> のほうが常に大きくなります</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>あらゆる型</entry>
       <entry><type>object</type> のほうが常に大きくなります</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>一般的な配列の比較</title>
     <programlisting role="php">
<![CDATA[
<?php
// 標準の比較演算子を用いて、配列はこのように比較されます
function standard_array_compare($op1, $op2)
{
    if (count($op1) < count($op2)) {
        return -1; // $op1 < $op2
    } elseif (count($op1) > count($op2)) {
        return 1; // $op1 > $op2
    }
    foreach ($op1 as $key => $val) {
        if (!array_key_exists($key, $op2)) {
            return null; // uncomparable
        } elseif ($val < $op2[$key]) {
            return -1;
        } elseif ($val > $op2[$key]) {
            return 1;
        }
    }
    return 0; // $op1 == $op2
}
?>
]]>
     </programlisting>
    </example> 
   </para>

   <para>
    <function>strcasecmp</function>,
    <function>strcmp</function>、
    <link linkend="language.operators.array">配列演算子</link>,
    マニュアルの
    <link linkend="language.types">型</link> のセクションも参照してください。
   </para>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>三項演算子</title>
    <para>
     もうひとつの条件演算子として "?:"（あるいは三項）演算子があります。
     <example>
      <title>デフォルト値を設定する</title>
      <programlisting role="php">
<![CDATA[
<?php
// 三項演算子の使用例
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// 上記は以下の if/else 式と同じです。
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example> 
     <literal>(expr1) ? (expr2) : (expr3)</literal>
     という式は、<replaceable>式1</replaceable> が &true; の場合に
     <replaceable>式2</replaceable> を、
     <replaceable>式1</replaceable> が &false; の場合に
     <replaceable>式3</replaceable> を値とします。
    </para>
    <para>
     PHP 5.3 以降では、三項演算子のまんなかの部分をなくすこともできるようになりました。
     式 <literal>expr1 ?: expr3</literal> の結果は、<replaceable>expr1</replaceable> が
     &true; と同等の場合は <replaceable>expr1</replaceable>、
     それ以外の場合は <replaceable>expr3</replaceable> となります。
    </para>
    <note>
     <simpara>
      三項演算子は式であり、値としては評価されずに式の結果として評価される
      ことに注意してください。演算結果をリファレンスとして返したい場合に、
      これを知っておくことが大切です。結果をリファレンスとして返す関数で
      <literal>return $var == 42 ? $a : $b;</literal> とすることはできず、
      新しいバージョンの PHP では警告を発生します。
     </simpara>
    </note>
    <note>
     <para>
      三項演算子を "積み重ねて" 使用することは避けましょう。
      ひとつの文の中で複数の三項演算子を使用した際の PHP の振る舞いは、
      少々わかりにくいものです。
      <example>
       <title>三項演算子のわかりにくい挙動</title>
       <programlisting role="php">
<![CDATA[
<?php
// ぱっと見た感じでは、これは 'true' と表示されると思うでしょう。
echo (true?'true':false?'t':'f');

// しかし、実際には上の出力結果は 't' です。
// なぜなら、三項演算子は左から右へ順に評価されるからです。

// 上のコードをもう少しわかりやすく書くと、このようになります。
echo ((true ? 'true' : 'false') ? 't' : 'f');

// まず、最初の式が 'true' と評価されます。この 'true' は
// (bool)true と評価されるので、それをもとに二番目の三項
// 演算子が評価されます。
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>
 
  <sect1 xml:id="language.operators.errorcontrol">
   <title>エラー制御演算子</title>
   <simpara>
    PHP はエラー制御演算子(@)をサポートしています。PHP の式の前に付けた場合、
    その式により生成されたエラーメッセージは無視されます。
   </simpara>
   <simpara>
    <link linkend="ini.track-errors"><option>track_errors</option></link> 機能が
    有効な場合、式により生成されたエラーメッセージはグローバル変数
    <varname>$php_errormsg</varname>
    に保存されます。この変数はエラーが発生するたびに上書きされます。
    そのため、この変数を使用したい場合には速やかに確認する必要があります。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* 意図的なエラー */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// この演算子は関数だけでなく、全ての式で動作します。
$value = @$cache[$key]; 
// インデックス $key が存在しない場合でも、警告を発生しません。

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     @演算子は、<link linkend="language.expressions">式</link>
     でのみ動作します。基本的なルールは次のようになります。
     値を得ることができるものの場合、@ 演算子を前に付けることが可能です。
     例えば、変数、関数、<function>include</function>コール、定数等の
     前にこの演算子をつけることが可能です。関数またはクラスの定義や
     <literal>if</literal> や &foreach; 等のような
     条件構造の前にこの演算子を付けることはできません。
    </simpara>
   </note>
   <simpara>
    <function>error_reporting</function> と、
    <link linkend="ref.errorfunc">エラー処理とログ出力関数</link>
    も参照してください。
   </simpara>
   <warning>
    <para>
     現在、エラー制御演算子プレフィックス"@"は、スクリプトの実行を
     終了するような致命的なエラーの出力さえ抑圧します。このため、ある関数の
     エラー出力を抑制するために "@" を使用した場合、その関数が
     利用できなかったり、ミスタイプがあった場合でも、原因を示すことなく
     その場所でスクリプトは終了してしまいます。
    </para>
   </warning>
  </sect1>
  
  <sect1 xml:id="language.operators.execution">
   <title>実行演算子</title>
   <para>
    PHP は 1 種類の実行演算子、バッククォート (``) をサポートします。
    シングルクォートではないことに注意してください! PHP は、バッククォートの
    中身をシェルコマンドとして実行しようとします。出力が返されます
    (すなわち、出力を単にダンプするのではなく、変数に代入することが
    できます) 。
    バッククォート演算子の使用は <function>shell_exec</function> と等価です。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     バッククオート演算子は、&safemode; が有効な場合
     もしくは <function>shell_exec</function> が無効な場合は無効となります。
    </para>
   </note>
   <para>
    <function>escapeshellcmd</function>, <function>exec</function>,
    <function>passthru</function>, <function>popen</function>,
    <function>shell_exec</function>, <function>system</function>
    <link linkend="features.commandline">PHPをコマンドラインから使用する</link>
    も参照してください。
   </para>
  </sect1>
   
  <sect1 xml:id="language.operators.increment">
   <title>加算子/減算子</title>
   <para>
    PHP は C 言語形式の加算子/減算子（前置・後置ともに）をサポートします。
   </para>
   <note>
    <simpara>
     加算子/減算子は bool 型の値には何も変更を加えません。
     同じく &null; に減算子を適用しても何も起こりませんが、&null; に加算子を
     適用すると <literal>1</literal> となります。
    </simpara>
   </note>
   <table>
    <title>加算子/減算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>効果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>前置加算子</entry>
       <entry><varname>$a</varname> に 1 を加え、<varname>$a</varname> を返します。</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>後置加算子</entry>
       <entry><varname>$a</varname> を返し、<varname>$a</varname> に1を加えます。</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>前置減算子</entry>
       <entry><varname>$a</varname> から 1 を引き、<varname>$a</varname> を返します。</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>後置減算子</entry>
       <entry><varname>$a</varname> を返し、<varname>$a</varname> から 1 を引きます。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    以下に簡単なスクリプトの例を示します。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>後置加算</h3>";
$a = 5;
echo "5 となります: " . $a++ . "<br>\n";
echo "6 となります: " . $a . "<br>\n";
 
echo "<h3>前置加算</h3>";
$a = 5;
echo "6 となります: " . ++$a . "<br>\n";
echo "6 となります: " . $a . "<br>\n";

echo "<h3>後置減算</h3>";
$a = 5;
echo "5 となります: " . $a-- . "<br>\n";
echo "4 となります: " . $a . "<br>\n";

echo "<h3>前置減算</h3>";
$a = 5;
echo "4 となります: " . --$a . "<br>\n";
echo "4 となります: " . $a . "<br>\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP は、算術演算子で文字変数を扱った場合に C ではなく Perl の慣習に
    従います。例えば、perl では <literal>'Z'+1</literal> は <literal>'AA'</literal> を返しますが C では <literal>'Z'+1</literal> は
    <literal>'['</literal> ( <literal>ord('Z') == 90</literal>, <literal>ord('[') == 91</literal> ) を返します。
    文字変数はインクリメントされることは可能ですがデクリメントは不可能であるということ、
    またプレーンな ASCII 文字 (a-z および A-Z) のみがサポートされるということに注意しましょう。
    <example>
     <title>文字変数に対する算術演算子の使用</title>
     <programlisting role="php">
<![CDATA[
<?php
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$i . "\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
X
Y
Z
AA
AB
AC
]]>
     </screen>
    </example>
   </para>
   <para>
    論理型に対する加算/減算は何の影響も及ぼしません。
   </para>
  </sect1>
 
  <sect1 xml:id="language.operators.logical">
   <title>論理演算子</title>
 
   <table>
    <title>論理演算子</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>論理積</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> が共に &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>論理和</entry>
       <entry><varname>$a</varname> または <varname>$b</varname> のどちらかが &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>排他的論理和</entry>
       <entry>
    <varname>$a</varname> または <varname>$b</varname> のどちらかが &true; でかつ両方とも &true; でない場合に &true;
       </entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>否定</entry>
       <entry><varname>$a</varname> が &true; でない場合 &true;</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>論理積</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> が共に &true; の場合に &true;</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>論理和</entry>
       <entry><varname>$a</varname> または <varname>$b</varname> のどちらかが &true; の場合に &true;</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    "and" および "or" 演算子が 2 種類あるのは、演算が行われる際の優先順位が
    異なっているためです
    (<link linkend="language.operators.precedence">演算子の優先順位</link>
    を参照ください)。
   </simpara>
   <example>
    <title>論理演算子についての説明</title>
    <programlisting role="php">
<![CDATA[
<?php

// foo() は決してコールされることはありません。これらの演算子は短絡評価を行うからです。
$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// "||" の優先順位は "or" より高くなります
$e = false || true; // $e に代入されるのは、(false || true) の評価結果、つまり true です
$f = false or true; // $f には false が代入されます
var_dump($e, $f);

// "&&" の優先順位は "and" より高くなります
$g = true && false; // $g に代入されるのは、(true && false) の評価結果、つまり false です
$h = true and false; // $h には true が代入されます
var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>文字列演算子</title>
   <simpara>
    文字列の演算子は 2 種類あります。最初のは結合演算子('.')で、右引数と
    左引数を結合したものを返します。2 番目は、結合代入演算子('<literal>.=</literal>')で、
    この演算子は右側の引数に左側の引数を追加します。詳細は、<link
    linkend="language.operators.assignment">代入演算子</link> を
    参照ください。
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Hello ";
$b = $a . "World!"; // $b は、"Hello World!" となります。

$a = "Hello ";
$a .= "World!"; // $a は、"Hello World!" となります。
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <link linkend="language.types.string">文字列</link> と 
    <link linkend="ref.strings">文字列 関数</link>も参照してください。
   </para>
  </sect1>
  
  <sect1 xml:id="language.operators.array">
   <title>配列演算子</title>
   <table>
    <title>Array Operators</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例</entry>
       <entry>名前</entry>
       <entry>結果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>結合</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> を結合する。</entry>
      </row>
      <row>
       <entry>$a == $b</entry>
       <entry>同等</entry>
       <entry><varname>$a</varname> および <varname>$b</varname> のキー/値のペアが等しい場合に &true;。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>同一</entry>
       <entry>
        <varname>$a</varname> および <varname>$b</varname> のキー/値のペアが等しく、その並び順が等しく、
        かつデータ型も等しい場合に &true;。
       </entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>等しくない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> と等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>等しくない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> と等しくない場合に &true;。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>同一でない</entry>
       <entry><varname>$a</varname> が <varname>$b</varname> と同一でない場合に &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <literal>+</literal> 演算子は、
    右側の配列の要素のうち、左側の配列に存在しないキーのものを左側の配列に追加します。
    重複しているキーは上書き「されません」。
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "apple", "b" => "banana");
$b = array("a" => "pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b; // Union of $a and $b
echo "Union of \$a and \$b: \n";
var_dump($c);

$c = $b + $a; // Union of $b and $a
echo "Union of \$b and \$a: \n";
var_dump($c);
?>
]]>
     </programlisting>
    </informalexample>
    このスクリプトを実行すると、以下のように出力されます。
    <screen role="php">
<![CDATA[
Union of $a and $b:
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=>
  string(4) "pear"
  ["b"]=>
  string(10) "strawberry"
  ["c"]=>
  string(6) "cherry"
}
]]>
    </screen>
   </para>
   <para>
    同じキーと値を保持している場合に、配列が等しいとみなされます。
   </para>
   <para>
    <example>
     <title>配列の比較</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <link linkend="language.types.array">配列</link>と 
    <link linkend="ref.array">配列関数</link>も参照してください。
   </para>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>型演算子</title>
   <para>
    <literal>instanceof</literal> を使用して、
    ある PHP 変数が特定の
    <link linkend="language.oop5.basic.class">クラス</link>
    のオブジェクトのインスタンスであるかどうかを調べます。
    <example>
     <title>クラスでの instanceof の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

class NotMyClass
{
}
$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof NotMyClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> は、ある変数が
    特定の親クラスを継承したクラスのオブジェクトのインスタンスであるかどうかを調べることもできます。
    <example>
     <title>継承したクラスでの <literal>instanceof</literal> の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    あるオブジェクトが特定のクラスのインスタンスで <emphasis>ない</emphasis>
    ことを調べるには、
    <link linkend="language.operators.logical">論理 <literal>否定</literal> 演算子</link>
    を使用します。
    <example>
     <title><literal>instanceof</literal> を使用して、オブジェクトがクラスのインスタンスで <emphasis>ない</emphasis>
      かどうかを調べる方法</title>
     <programlisting role="php">
<![CDATA[
<?php
class MyClass
{
}

$a = new MyClass;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    最後に、<literal>instanceof</literal>
    は、ある変数が特定の
    <link linkend="language.oop5.interfaces">インターフェイス</link>
    を実装したクラスのオブジェクトのインスタンスであるかどうかも調べることができます。
    <example>
     <title>クラスでの <literal>instanceof</literal> の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;

var_dump($a instanceof MyClass);
var_dump($a instanceof MyInterface);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    通常、<literal>instanceof</literal> ではリテラルのクラス名を使用しますが、
    別のオブジェクトや文字列変数を使用することもできます。
    <example>
     <title>変数を用いた <literal>instanceof</literal> の使用法</title>
     <programlisting role="php">
<![CDATA[
<?php
interface MyInterface
{
}

class MyClass implements MyInterface
{
}

$a = new MyClass;
$b = new MyClass;
$c = 'MyClass';
$d = 'NotMyClass';

var_dump($a instanceof $b); // $b MyClass クラスのオブジェクトです
var_dump($a instanceof $c); // $c は文字列 'MyClass' です
var_dump($a instanceof $d); // $d は文字列 'NotMyClass' です
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    注意すべき落とし穴があります。PHP 5.1.0 より前のバージョンでは、
    <literal>instanceof</literal> は、クラス名が存在しない場合に
    <link linkend="language.oop5.autoload">__autoload()</link> をコールしていました。
    さらに、クラスが読み込めなかった場合に致命的なエラーが発生していました。
    この問題の回避策としては、動的なクラス参照を使用するか、
    クラス名を含む文字列変数を使用します。
    <example>
     <title>PHP 5.0 における、クラス名検索時の致命的エラーの回避策</title>
     <programlisting role="php">
<![CDATA[
<?php
$d = 'NotMyClass';
var_dump($a instanceof $d); // これで、致命的なエラーは発生しません
?>
     ]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    <literal>instanceof</literal> 演算子は PHP 5 から使用可能になりました。
    それ以前には <function>is_a</function> が使用されていましたが、
    現在は <function>is_a</function> は推奨されておらず、
    <literal>instanceof</literal> の使用が推奨されています。
    PHP 5.3.0 以降、<function>is_a</function> は非推奨ではなくなったことに注意しましょう。
   </simpara>
   <para>
    <function>get_class</function> および
    <function>is_a</function> も参照ください。
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
