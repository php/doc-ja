<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 86d3fb841e0206e2588896ad3c21432333535848 Maintainer: mumumu Status: ready -->
<section xmlns="http://docbook.org/ns/docbook" xml:id="pdo.constants.fetch-modes">
 <title>フェッチモード</title>

 <simpara>
  <literal>PDO::FETCH_ORI_*</literal> カーソル定数については、
  <link linkend="pdo.constants.cursors">カーソル定数</link> を参照ください。
 </simpara>

 <section xml:id="pdo.fetch-modes.basic" annotations="chunk:false">
  <title>基本的なフェッチモード</title>
  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>フェッチモード</entry>
      <entry>概要</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_DEFAULT</constant>
      </entry>
      <entry>
       現在のデフォルトフェッチモードを使用するための特別な値。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_ASSOC</constant>
      </entry>
      <entry>
       カラム名のみでインデックス付けされた配列。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_BOTH</constant> (デフォルト)
      </entry>
      <entry>
       カラム番号とカラム名の両方でインデックス付けされた配列。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NAMED</constant>
      </entry>
      <entry>
       重複するカラムを保持する <constant>PDO::FETCH_ASSOC</constant> の変形。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_NUM</constant>
      </entry>
      <entry>
       カラム番号のみでインデックス付けされた配列。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_COLUMN</constant>
      </entry>
      <entry>
       単一のカラム。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_KEY_PAIR</constant>
      </entry>
      <entry>
       最初のカラムでインデックス付けされたキーと値のペア。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_FUNC</constant>
      </entry>
      <entry>
       戻り値を生成するために関数を使用します。
       (<methodname>PDOStatement::fetchAll</methodname> のみ)
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_OBJ</constant>
      </entry>
      <entry>
       無名の (<classname>stdClass</classname>) オブジェクト。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASS</constant>
      </entry>
      <entry>
       指定されたクラスのオブジェクト。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.class-flags" annotations="chunk:false">
  <title>PDO::FETCH_CLASS のオプション</title>

  <simpara>
   これらのモードは <constant>PDO::FETCH_CLASS</constant>
   使用時のオプションを実装するために使用されます。
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>フェッチモード</entry>
      <entry>概要</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_CLASSTYPE</constant>
      </entry>
      <entry>
       最初のカラムをクラス名として使用します。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_PROPS_LATE</constant>
      </entry>
      <entry>
       プロパティを設定する前にコンストラクタを呼び出します。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_SERIALIZE</constant>
      </entry>
      <entry>
       PHP のシリアライズされたデータを使用します。PHP 8.1.0 以降は推奨されません。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.single" annotations="chunk:false">
  <title>単一結果モード</title>

  <simpara>
   以下のモードは <methodname>PDOStatement::fetchAll</methodname>
   では使用できません。
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>フェッチモード</entry>
      <entry>概要</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_BOUND</constant>
      </entry>
      <entry>
       指定した変数に値をバインドします。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_INTO</constant>
      </entry>
      <entry>
       既存のオブジェクトを更新します。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_LAZY</constant>
      </entry>
      <entry>
       配列風およびオブジェクト風のアクセスのための
       <classname>PDORow</classname> による遅延フェッチ。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.grouped" annotations="chunk:false">
  <title>
   <methodname>PDOStatement::fetchAll</methodname> 用の特殊な動作フラグ
  </title>

  <simpara>
   以下の複数結果用の特殊モードは
   <methodname>PDOStatement::fetchAll</methodname> でのみ動作し、
   一部の他のフェッチモードとは組み合わせて使用できません。
   詳細については完全なドキュメントを確認してください。
  </simpara>

  <informaltable>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>フェッチモード</entry>
      <entry>概要</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>
       <constant>PDO::FETCH_GROUP</constant>
      </entry>
      <entry>
       結果は最初のカラムでグループ化されます。
      </entry>
     </row>
     <row>
      <entry>
       <constant>PDO::FETCH_UNIQUE</constant>
      </entry>
      <entry>
       結果は最初のカラムで (一意に) インデックス付けされます。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </section>

 <section xml:id="pdo.fetch-modes.duplicate-names" annotations="chunk:false">
  <title>重複するカラム名の処理</title>
  <simpara>
   結果に同じ名前のカラムが複数含まれる場合があります。
   たとえば、同じカラム名を持つ 2 つのテーブルを結合する場合などです。
  </simpara>
  <simpara>
   PHP の配列やオブジェクトなどの構造は、同じ名前の複数のキーや
   プロパティをサポートしていないため、返される配列やオブジェクトには
   同じ名前を使用する値のうち 1 つだけが含まれます。
  </simpara>
  <simpara>
   重複する名前に対してどの値が返されるかは未定義と考えるべきです。
  </simpara>
  <simpara>
   この問題を回避するには、エイリアスを使用してカラムに明示的に名前を付けてください。
   例:
  </simpara>
  <informalexample>
   <programlisting role="sql">
<![CDATA[
SELECT table1.created_at AS t1_created_at,
       table2.created_at AS t2_created_at
FROM table1
JOIN table2 ON table1.table2id = table2.id
]]>
   </programlisting>
  </informalexample>
  <simpara>
   <constant>PDO::FETCH_NAMED</constant>、
   <constant>PDO::ATTR_FETCH_TABLE_NAMES</constant> および
   <constant>PDO::ATTR_FETCH_CATALOG_NAMES</constant> も参照ください。
  </simpara>
 </section>

 <section xml:id="pdo.fetch-modes.default" annotations="chunk:false">
  <title>デフォルトのフェッチモードの設定</title>
  <simpara>
   <methodname>PDO::__construct</methodname> または
   <methodname>PDO::setAttribute</methodname> で
   <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant>
   を使用して、すべてのクエリに対するデフォルトのフェッチモードを設定できます。
  </simpara>
  <simpara>
   特定のステートメントに対するデフォルトのフェッチモードは、
   <methodname>PDOStatement::setFetchMode</methodname> を使用して設定できます。
   これはプリペアドステートメントの再利用や (&foreach; を使用した)
   イテレーションに影響します。
  </simpara>
  <caution>
   <simpara>
    <methodname>PDOStatement::setAttribute</methodname> はデフォルトのフェッチモードの
    設定には使用できません。ドライバ固有の属性のみを受け入れ、
    認識されない属性は警告なく無視されます。
   </simpara>
  </caution>
 </section>

 <section xml:id="pdo.constants.fetch-default" annotations="chunk:false">
  <title>PDO::FETCH_DEFAULT (<type>int</type>)</title>
  <simpara>
   PHP 8.0.7 以降で利用可能です。
  </simpara>
  <simpara>
   これは <classname>PDOStatement</classname>
   に対する現在のデフォルトのフェッチモードを使用する特別な値です。
   <constant>PDO::ATTR_STATEMENT_CLASS</constant> と共に使用するために
   <classname>PDOStatement</classname>
   を拡張する際のメソッドパラメータのデフォルト値として特に有用です。
  </simpara>
  <para>
   この値は <constant>PDO::ATTR_DEFAULT_FETCH_MODE</constant>
   と共には使用できません。
  </para>
 </section>

 <section xml:id="pdo.constants.fetch-assoc" annotations="chunk:false">
  <title>PDO::FETCH_ASSOC (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_ASSOC</constant> はカラム名のみでインデックス付けされた
   配列を返します。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-both" annotations="chunk:false">
  <title>PDO::FETCH_BOTH (<type>int</type>)</title>
  <simpara>
   これはデフォルトのフェッチモードです。
  </simpara>
  <simpara>
   <constant>PDO::FETCH_BOTH</constant> はカラム番号とカラム名の両方で
   インデックス付けされた配列を返します。これは、結果行ごとに
   すべての返される値が重複することを意味します。
  </simpara>
  <simpara>
   カラム番号は 0 から始まり、クエリ内の結果カラムの順序によって決まります。
   テーブルでカラムが定義されている順序などではありません。
  </simpara>
  <note>
   <simpara>
    数値カラムインデックスの使用は推奨されません。
    クエリが変更された場合や、<literal>SELECT *</literal>
    を使用している場合にテーブルスキーマが変更されると、
    インデックスが変わる可能性があるためです。
   </simpara>
  </note>
  <note>
   <simpara>
    複数の返されるカラムが同じ名前を使用する場合、
    名前でインデックス付けされたエントリの数は
    番号でインデックス付けされたエントリの数と一致しないことがあります。
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_BOTH);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [id] => 104,
    [0] => 104,
    [name] => Chris,
    [1] => Chris,
    [country] => Ukraine,
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-named" annotations="chunk:false">
  <title>PDO::FETCH_NAMED (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_NAMED</constant> は
   <constant>PDO::FETCH_ASSOC</constant> と同じ形式で結果を返しますが、
   複数のカラムが同じ名前を使用する場合、すべての値がリストとして返されます。
  </simpara>
  <simpara>
   重複するカラム名の処理と代替方法についての詳細は、上記の
   <link linkend="pdo.fetch-modes.duplicate-names">重複する名前の処理に関する
   セクション</link> を参照ください。
  </simpara>
  <simpara>
   重複した値が返される順序は未定義と考えるべきです。
   各値がどこから来たのかを知る方法はありません。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query(
    "SELECT users.*, referrer.name
     FROM users
     LEFT JOIN users AS referrer ON users.referred_by = referrer.userid
     WHERE userid = 109"
);
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [userid] => 109
    [name] => Array
        (
            [0] => Toni
            [1] => Chris
        )
    [country] => Germany
    [referred_by] = 104
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-num" annotations="chunk:false">
  <title>PDO::FETCH_NUM (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_NUM</constant> はカラム番号のみでインデックス付けされた
   配列を返します。カラム番号は 0 から始まり、
   クエリ内の結果カラムの順序によって決まります。
   テーブルでカラムが定義されている順序などではありません。
  </simpara>
  <note>
   <simpara>
    数値カラムインデックスの使用は推奨されません。
    クエリが変更された場合や、<literal>SELECT *</literal>
    を使用している場合にテーブルスキーマが変更されると、
    インデックスが変わる可能性があるためです。
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_NUM);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => 104
    [1] => Chris
    [2] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-column" annotations="chunk:false">
  <title>PDO::FETCH_COLUMN (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_COLUMN</constant> は単一のカラムの値を返します。
   <methodname>PDOStatement::setFetchMode</methodname> または
   <methodname>PDOStatement::fetchAll</methodname>
   の第二引数を使用して、どのカラムを返すかを指定します。
  </simpara>
  <simpara>
   指定されたカラムが存在しない場合、
   <classname>ValueError</classname> がスローされます。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN);
print_r($row);

$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_COLUMN, 1);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Chris
    [1] => Jamie
    [2] => Robin
)

Array
(
    [0] => Ukraine
    [1] => England
    [2] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-key-pair" annotations="chunk:false">
  <title>PDO::FETCH_KEY_PAIR (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_KEY_PAIR</constant> は最初のカラムでインデックス付けされた
   値のペアを返します。結果には 2 つのカラムのみが含まれている必要があります。
   このフェッチモードは <methodname>PDOStatement::fetchAll</methodname>
   でのみ意味があります。
  </simpara>
  <note>
   <simpara>
    最初のカラムが一意でない場合、値が失われます。
    どの値が失われるかは未定義と考えるべきです。
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_KEY_PAIR);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Chris] => Ukraine
    [Jamie] => England
    [Robin] => Germany
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-func" annotations="chunk:false">
  <title>PDO::FETCH_FUNC (<type>int</type>)</title>
  <simpara>
   返される値を生成するための関数を指定します。このモードは
   <methodname>PDOStatement::fetchAll</methodname> でのみ使用できます。
  </simpara>
  <simpara>
   関数は値をパラメータとして受け取ります。
   指定された値がどのカラム名に関連付けられているかを取得する方法はありません。
   クエリ内のカラムの順序が関数のパラメータの順序と一致していることを
   確認することが重要です。
  </simpara>
  <note>
   <simpara>
    <constant>PDO::FETCH_GROUP</constant> および
    <constant>PDO::FETCH_UNIQUE</constant>
    の効果は、関数が呼び出される前に結果に適用されます。
   </simpara>
  </note>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function valueCreator($col1, $col2, $col3)
{
    return [
        'col1' => $col1,
        'col2' => strtoupper($col2),
        'col3' => $col3,
        'customKey' => 'customValue',
    ];
}

$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_FUNC, valueCreator(...));
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [0] => Array
        (
            [col1] => 104
            [col2] => SAM
            [col3] => Ukraine
            [customKey] => customValue
        )

    [1] => Array
        (
            [col1] => 105
            [col2] => JAMIE
            [col3] => England
            [customKey] => customValue
        )

    [2] => Array
        (
            [col1] => 107
            [col2] => ROBIN
            [col3] => Germany
            [customKey] => customValue
        )

)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-obj" annotations="chunk:false">
  <title>PDO::FETCH_OBJ (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_OBJ</constant> は <classname>stdClass</classname>
   オブジェクトを返します。
  </simpara>
  <simpara>
   <methodname>PDOStatement::fetchObject</methodname> および
   <constant>PDO::FETCH_CLASS</constant> も参照ください。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users");
$row = $stmt->fetch(\PDO::FETCH_OBJ);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
stdClass Object
(
    [userid] => 104
    [name] => Chris
    [country] => Ukraine
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-class" annotations="chunk:false">
  <title>PDO::FETCH_CLASS (<type>int</type>)</title>
  <simpara>
   指定されたクラスのオブジェクトを返します。追加の動作については
   <link linkend="pdo.fetch-modes.class-flags">オプションフラグ</link>
   を参照ください。
  </simpara>
  <simpara>
   返されるカラム名と一致するプロパティが存在しない場合、
   そのプロパティは動的に宣言されます。この動作は推奨されず、
   PHP 9.0 からはエラーが発生します。
  </simpara>
  <simpara>
   <methodname>PDOStatement::fetchObject</methodname> も参照ください。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? Yes
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-classtype" annotations="chunk:false">
  <title>PDO::FETCH_CLASSTYPE (<type>int</type>)</title>
  <simpara>
   このフェッチモードは <constant>PDO::FETCH_CLASS</constant>
   (および <link linkend="pdo.fetch-modes.class-flags">その他のオプション</link>)
   と組み合わせてのみ使用できます。
  </simpara>
  <simpara>
   このフェッチモードが使用されると、PDO は返される最初のカラムを
   返すクラスの名前として使用します。
  </simpara>
  <simpara>
   指定されたクラスが見つからない場合、警告やエラーなしに
   <classname>stdClass</classname> オブジェクトが返されます。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT 'TestEntity', userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_CLASSTYPE);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? Yes
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-props-late" annotations="chunk:false">
  <title>PDO::FETCH_PROPS_LATE (<type>int</type>)</title>
  <simpara>
   このフェッチモードは <constant>PDO::FETCH_CLASS</constant>
   (および <link linkend="pdo.fetch-modes.class-flags">その他のオプション</link>)
   と組み合わせてのみ使用できます。
  </simpara>
  <simpara>
   このフェッチモードが使用されると、プロパティが設定される前に
   コンストラクタが呼び出されます。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with ". count(func_get_args()) ." args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }
}

$stmt = $db->query(
    "SELECT userid, name, country, referred_by_userid FROM users"
);
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Constructor called with 0 args
Properties set when constructor called? No
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-serialize" annotations="chunk:false">
  <title>PDO::FETCH_SERIALIZE (<type>int</type>)</title>
  &warn.deprecated.feature-8-1-0;
  <simpara>
   このフェッチモードは <constant>PDO::FETCH_CLASS</constant>
   (および <link linkend="pdo.fetch-modes.class-flags">その他のオプション</link>)
   と組み合わせてのみ使用できます。
  </simpara>
  <simpara>
   このフェッチモードが使用される場合、指定されたクラスは
   <interfacename>Serializable</interfacename> でなければなりません。
  </simpara>
  <caution>
   <simpara>
    この機能は (<function>serialize</function> による)
    完全なシリアライズされたオブジェクトを含む文字列をサポートしていません。
   </simpara>
  </caution>
  <caution>
   <simpara>
    このフェッチモードはコンストラクタを呼び出しません。
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity implements Serializable
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;

    public function __construct()
    {
        print "Constructor called with " . count(func_get_args()) . " args\n";
        print "Properties set when constructor called? "
            . (isset($this->name) ? 'Yes' : 'No') . "\n";
    }

    public function serialize()
    {
        return join(
            "|",
            [$this->userid, $this->name, $this->country, $this->referred_by_userid]
        );
    }

    public function unserialize(string $data)
    {
        $parts = explode("|", $data);
        $this->userid = (int) $parts[0];
        $this->name = $parts[1];
        $this->country = $parts[2];

        $refId = $parts[3];
        $this->referred_by_userid = ($refId === "" ? null : (int) $refId);
    }
}

print "Set up record (constructor called manually):\n";
$db->exec(
    "CREATE TABLE serialize (
        sdata TEXT
    )"
);

$origObj = new TestEntity();
$origObj->userid = 200;
$origObj->name = 'Seri';
$origObj->country = 'Syria';
$origObj->referred_by_userid = null;

$insert = $db->prepare("INSERT INTO serialize (sdata) VALUES (:sdata)");
$insert->execute(['sdata' => $origObj->serialize()]);

print "\nRetrieve result:\n";
$query = "SELECT sdata FROM serialize";
$stmt = $db->query($query);
// 注意: コンストラクタは呼び出されません！
$stmt->setFetchMode(PDO::FETCH_CLASS | PDO::FETCH_SERIALIZE, TestEntity::class);
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
Deprecated: TestEntity implements the Serializable interface, which is deprecated. Implement __serialize() and __unserialize() instead (or in addition, if support for old PHP versions is necessary) in Standard input code on line 2
Set up record (constructor called manually):
Constructor called with 0 args
Properties set when constructor called? No

Retrieve result:
Deprecated: PDOStatement::setFetchMode(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 58

Deprecated: PDOStatement::fetch(): The PDO::FETCH_SERIALIZE mode is deprecated in Standard input code on line 59
object(TestEntity)#5 (4) {
  ["userid"]=>
  int(200)
  ["name"]=>
  string(4) "Seri"
  ["country"]=>
  string(5) "Syria"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-bound" annotations="chunk:false">
  <title>PDO::FETCH_BOUND (<type>int</type>)</title>
  <simpara>
   このフェッチモードは <methodname>PDOStatement::fetchAll</methodname>
   では使用できません。
  </simpara>
  <simpara>
   このフェッチモードは結果を直接返すのではなく、
   <methodname>PDOStatement::bindColumn</methodname>
   で指定された変数に値をバインドします。
   呼び出されたフェッチメソッドは &true; を返します。
  </simpara>
  <note>
   <simpara>
    プリペアドステートメントを使用する場合、正しく動作させるには
    クエリが実行された後に変数をバインドする必要があります。
   </simpara>
  </note>
  <programlisting role="php">
<![CDATA[
<?php
$query = "SELECT users.userid, users.name, users.country, referrer.name
    FROM users
    LEFT JOIN users AS referrer ON users.referred_by_userid = referrer.userid";
$stmt = $db->prepare($query);
$stmt->execute();

$stmt->bindColumn('userid', $userId);
$stmt->bindColumn('name', $name);
$stmt->bindColumn('country', $country);
// 重複するカラム名を解決するためにカラム位置でバインドする
// クエリが変更された場合に壊れないようにするには、SQL エイリアスを使用してください
// 例: referrer.name AS referrer_name
$stmt->bindColumn(4, $referrerName);

while ($stmt->fetch(\PDO::FETCH_BOUND)) {
    print join("\t", [$userId, $name, $country, ($referrerName ?? 'NULL')]) . "\n";
}
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
104	Chris	Ukraine	NULL
105	Jamie	England	NULL
107	Robin	Germany	Chris
108	Sean	Ukraine	NULL
109	Toni	Germany	NULL
110	Toni	Germany	NULL
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-into" annotations="chunk:false">
  <title>PDO::FETCH_INTO (<type>int</type>)</title>
  <simpara>
   このフェッチモードは <methodname>PDOStatement::fetchAll</methodname>
   では使用できません。
  </simpara>
  <simpara>
   このフェッチモードは指定されたオブジェクトのプロパティを更新します。
   成功した場合、オブジェクトが返されます。
  </simpara>
  <simpara>
   返されるカラム名と一致するプロパティが存在しない場合、
   そのプロパティは動的に宣言されます。この動作は推奨されず、
   PHP 9.0 からはエラーが発生します。
  </simpara>
  <simpara>
   プロパティは <literal>public</literal> でなければならず、
   <literal>readonly</literal> にはできません。
  </simpara>
  <caution>
   <simpara>
    各レコードの取得間で
    <methodname>PDOStatement::setFetchMode</methodname>
    を使用せずに、更新対象のオブジェクトを変更する方法はありません。
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class TestEntity
{
    public $userid;

    public $name;

    public $country;

    public $referred_by_userid;
}

$obj = new TestEntity();
$stmt->setFetchMode(\PDO::FETCH_INTO, $obj);

$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch();
var_dump($result);
]]>
   </programlisting>
   &example.outputs.similar;
   <screen>
<![CDATA[
object(TestEntity)#3 (4) {
  ["userid"]=>
  int(104)
  ["name"]=>
  string(5) "Chris"
  ["country"]=>
  string(7) "Ukraine"
  ["referred_by_userid"]=>
  NULL
}
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-lazy" annotations="chunk:false">
  <title>PDO::FETCH_LAZY (<type>int</type>)</title>
  <simpara>
   このフェッチモードは <methodname>PDOStatement::fetchAll</methodname>
   では使用できません。
  </simpara>
  <simpara>
   このフェッチモードは <classname>PDORow</classname> オブジェクトを返し、
   値への配列風およびオブジェクト風のアクセスを提供します
   (つまり、<constant>PDO::FETCH_BOTH</constant> と
   <constant>PDO::FETCH_OBJ</constant> の動作を組み合わせたもの)。
   値は遅延的に取得されます。
  </simpara>
  <simpara>
   これは、データベースサーバー上のバッファリングされていない結果への
   (PHP 側で) メモリ効率の良いアクセスを提供できます。
   PDO が結果にクライアント側のバッファリングを使用するかどうかは、
   使用されるデータベース固有のドライバ (およびその設定) に依存します。
  </simpara>
  <caution>
   <simpara>
    <classname>PDORow</classname> は、定義されていないプロパティやキーに
    アクセスした場合、エラーや警告なしに <literal>NULL</literal> を返します。
    これにより、タイプミスや期待されるデータを返さないクエリなどのエラーを
    発見してデバッグすることが難しくなる可能性があります。
   </simpara>
  </caution>
  <caution>
   <simpara>
    返される <classname>PDORow</classname> オブジェクトは、
    結果が取得されるたびに更新されます。
   </simpara>
  </caution>
  <programlisting role="php">
<![CDATA[
<?php
$stmt = $db->query("SELECT userid, name, country, referred_by_userid FROM users");
$result = $stmt->fetch(\PDO::FETCH_LAZY);

print "ID: ". $result[0] ."\n";
print "Name: {$result->name}\n";
print "Country: " . $result['country'] ."\n";
// NULL を返します。警告やエラーは発生しません。
print "Does not exist: " . var_export($result->does_not_exist, true) . "\n";

$differentResult = $stmt->fetch(\PDO::FETCH_LAZY);
// 以前取得した PDORow は、新しく取得された結果を指すようになります
print "ID: ". $result[0] ."\n";

]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
ID: 104
Name: Chris
Country: Ukraine
Does not exist: NULL
ID: 105
]]>
  </screen>
 </section>

 <section xml:id="pdo.constants.fetch-group" annotations="chunk:false">
  <title>PDO::FETCH_GROUP (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_GROUP</constant> は、(一意でない) カラムで
   インデックス付けされた連想配列のリストを返します。
   このフェッチモードは <methodname>PDOStatement::fetchAll</methodname>
   でのみ動作します。
  </simpara>
  <simpara>
   <constant>PDO::FETCH_UNIQUE</constant> と組み合わせた場合、
   両方のモードが同じカラムを使用するため、
   これらのモードの組み合わせは無意味になります。
  </simpara>
  <simpara>
   このフェッチは
   <constant>PDO::FETCH_ASSOC</constant>、<constant>PDO::FETCH_BOTH</constant>、
   <constant>PDO::FETCH_NAMED</constant>、<constant>PDO::FETCH_NUM</constant>、
   <constant>PDO::FETCH_COLUMN</constant> または
   <constant>PDO::FETCH_FUNC</constant> のいずれかと組み合わせる必要があります。
  </simpara>
  <simpara>
   上記のリストのフェッチモードが指定されない場合、
   <classname>PDOStatement</classname>
   の現在のデフォルトのフェッチモードが使用されます。
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT country, userid, name FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                )
        )
)
]]>
   </screen>
  </informalexample>
  <simpara>
   上記の例では、最初のカラムが各行の配列から省略され、
   キーとしてのみ利用可能であることに注意してください。
   次の例のようにカラムを繰り返すことで含めることができます:
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT country, userid, name, country FROM users");
$row = $stmt->fetchAll(\PDO::FETCH_GROUP | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [Ukraine] => Array
        (
            [0] => Array
                (
                    [userid] => 104
                    [name] => Chris
                    [country] => Ukraine
                )

            [1] => Array
                (
                    [userid] => 108
                    [name] => Sean
                    [country] => Ukraine
                )

        )
    [England] => Array
        (
            [0] => Array
                (
                    [userid] => 105
                    [name] => Jamie
                    [country] => England
                )

        )

    [Germany] => Array
        (
            [0] => Array
                (
                    [userid] => 107
                    [name] => Robin
                    [country] => Germany
                )

            [1] => Array
                (
                    [userid] => 109
                    [name] => Toni
                    [country] => Germany
                )
        )
)
]]>
   </screen>
  </informalexample>
 </section>

 <section xml:id="pdo.constants.fetch-unique" annotations="chunk:false">
  <title>PDO::FETCH_UNIQUE (<type>int</type>)</title>
  <simpara>
   <constant>PDO::FETCH_UNIQUE</constant> は最初のカラムを使用してレコードを
   インデックス付けし、インデックス値ごとに 1 レコードを返します。
   このフェッチモードは <methodname>PDOStatement::fetchAll</methodname>
   でのみ動作します。
  </simpara>
  <simpara>
   <constant>PDO::FETCH_GROUP</constant> と組み合わせた場合、
   両方のモードが同じカラムを使用するため、
   これらのモードの組み合わせは無意味になります。
  </simpara>
  <simpara>
   このフェッチは
   <constant>PDO::FETCH_ASSOC</constant>、<constant>PDO::FETCH_BOTH</constant>、
   <constant>PDO::FETCH_NAMED</constant>、<constant>PDO::FETCH_NUM</constant>、
   <constant>PDO::FETCH_COLUMN</constant> または
   <constant>PDO::FETCH_FUNC</constant> のいずれかと組み合わせる必要があります。
  </simpara>
  <simpara>
   上記のリストのフェッチモードが指定されない場合、
   <classname>PDOStatement</classname>
   の現在のデフォルトのフェッチモードが使用されます。
  </simpara>
  <simpara>
   一意であることがわかっているカラム (レコード ID など) と共に使用すると、
   このモードはその値でインデックス付けされた結果を素早く返す機能を提供します。
  </simpara>
  <note>
   <simpara>
    最初のカラムが一意でない場合、値が失われます。
    どの値が失われるかは未定義と考えるべきです。
   </simpara>
  </note>
  <caution>
   <simpara>
    レコードのフィルタリングは、可能な限り SQL で行うべきです。
    データベースはインデックスを使用してこのプロセスを最適化し、
    必要なレコードのみを返します。
    必要以上のレコードをデータベースから取得すると、
    大きな結果セットの場合にメモリ使用量とクエリ時間が大幅に増加する可能性があります。
   </simpara>
  </caution>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
  <simpara>
   上記の例では、最初のカラムが各行の配列から省略され、
   キーとしてのみ利用可能であることに注意してください。
   次の例のようにカラムを繰り返すことで含めることができます:
  </simpara>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$stmt = $pdo->query("SELECT userid, userid, name, country FROM users LIMIT 3");
$row = $stmt->fetchAll(\PDO::FETCH_UNIQUE | \PDO::FETCH_ASSOC);
print_r($row);
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Array
(
    [104] => Array
        (
            [userid] => 104
            [name] => Chris
            [country] => Ukraine
        )

    [105] => Array
        (
            [userid] => 105
            [name] => Jamie
            [country] => England
        )

    [107] => Array
        (
            [userid] => 107
            [name] => Robin
            [country] => Germany
        )

)
]]>
   </screen>
  </informalexample>
 </section>

</section>
<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"~/.phpdoc/manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
 -->
